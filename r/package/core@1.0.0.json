{
  "$schema": "https://kitn.dev/schema/registry-item.json",
  "name": "core",
  "type": "kitn:package",
  "description": "Framework-agnostic AI agent engine — agents, tools, storage, streaming, events, voice",
  "dependencies": [
    "ai",
    "zod"
  ],
  "devDependencies": [
    "@asteasolutions/zod-to-openapi"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "core/agents/execute-task.ts",
      "content": "import { tool } from \"ai\";\nimport { z } from \"zod\";\nimport type { UsageInfo } from \"../utils/ai-provider.js\";\nimport { runAgent } from \"./run-agent.js\";\nimport {\n  delegationStore,\n  getEventBus,\n  getOrchestratorAgents,\n  type DelegationContext,\n} from \"../utils/delegation-context.js\";\nimport { TOOL_NAMES, DEFAULTS } from \"../utils/constants.js\";\nimport { BUS_EVENTS, STATUS_CODES } from \"../events/events.js\";\nimport { emitStatus } from \"../events/emit-status.js\";\nimport type { PluginContext } from \"../types.js\";\nimport { createMemoryTool, getDefaultMemoryStore } from \"./memory-tool.js\";\n\nconst clarifyItemSchema = z.object({\n  type: z.enum([\"question\", \"option\", \"confirmation\", \"action\", \"warning\", \"info\"]),\n  text: z.string(),\n  choices: z.array(z.string()).optional().describe(\"Required when type is 'option'\"),\n  context: z.string().optional(),\n});\n\nexport type ClarifyItem = z.infer<typeof clarifyItemSchema>;\n\nconst CLARIFY_TOOL = tool({\n  description:\n    \"Use when you need information, confirmation, or approval from the user. \" +\n    \"Supports: question (free text), option (pick from choices), \" +\n    \"confirmation (yes/no), action (declare intent), warning (risk), info (status update). \" +\n    \"Only use when you genuinely cannot proceed without user interaction.\",\n  inputSchema: z.object({ items: z.array(clarifyItemSchema) }),\n});\n\nconst MEMORY_PROMPT_SUFFIX =\n  \"\\n\\nYou have access to a memory tool for storing and retrieving information. \" +\n  \"Use it to remember important facts, user preferences, or intermediate results. \" +\n  \"Actions: set (save), get (retrieve by key), list (show all), delete (remove).\";\n\nconst CLARIFY_PROMPT_SUFFIX =\n  \"\\n\\nIMPORTANT: If the user's query is vague or lacks specifics needed to give a good answer, \" +\n  \"you MUST use the clarify tool to ask for more information. Do NOT guess, do NOT ask in plain text, \" +\n  \"and do NOT proceed without the needed details. Call clarify with items like: \" +\n  '{items: [{type: \"question\", text: \"Your question here\", context: \"Why you need this\"}]}.';\n\nexport interface TaskResult {\n  agent: string;\n  query: string;\n  result: {\n    response: string;\n    items?: ClarifyItem[];\n    toolsUsed: string[];\n    usage?: UsageInfo;\n  };\n  responseSkills?: string[];\n}\n\nfunction errorResult(agent: string, query: string, message: string): TaskResult {\n  return { agent, query, result: { response: message, toolsUsed: [] } };\n}\n\nexport async function executeTask(\n  ctx: PluginContext,\n  agent: string,\n  query: string,\n  skills?: string[],\n): Promise<TaskResult> {\n  const registration = ctx.agents.get(agent);\n  if (!registration) return errorResult(agent, query, `Unknown agent: ${agent}`);\n\n  if (getOrchestratorAgents(ctx.agents).has(agent)) {\n    return errorResult(agent, query, `Agent \"${agent}\" is an orchestrator and cannot be delegated to`);\n  }\n\n  if (!registration.tools || Object.keys(registration.tools).length === 0) {\n    return errorResult(agent, query, `Agent \"${agent}\" does not support task execution`);\n  }\n\n  const parentCtx = delegationStore.getStore();\n  const chain = parentCtx?.chain ?? [];\n  const depth = parentCtx?.depth ?? 0;\n\n  if (depth >= ctx.maxDelegationDepth) {\n    return errorResult(agent, query, `Delegation depth limit (${ctx.maxDelegationDepth}) exceeded. Chain: ${chain.join(\" → \")} → ${agent}`);\n  }\n\n  if (chain.length > 0 && chain[chain.length - 1] === agent) {\n    return errorResult(agent, query, `Self-delegation blocked: \"${agent}\" cannot delegate to itself`);\n  }\n\n  if (chain.includes(agent)) {\n    return errorResult(agent, query, `Circular delegation blocked: ${chain.join(\" → \")} → ${agent}`);\n  }\n\n  const bus = getEventBus();\n  const from = chain.length > 0 ? chain[chain.length - 1] : (parentCtx?.orchestrator ?? agent);\n\n  let systemPrompt = ctx.agents.getResolvedPrompt(agent)!;\n  const querySkillNames: string[] = [];\n  const responseSkillNames: string[] = [];\n\n  if (skills && skills.length > 0) {\n    const skillSections: string[] = [];\n    for (const skillName of skills) {\n      const skill = await ctx.storage.skills.getSkill(skillName);\n      if (!skill) continue;\n      if (skill.phase === \"query\" || skill.phase === \"both\") {\n        skillSections.push(`### ${skill.name}\\n${skill.content}`);\n        querySkillNames.push(skill.name);\n      }\n      if (skill.phase === \"response\" || skill.phase === \"both\") {\n        responseSkillNames.push(skill.name);\n      }\n    }\n    if (skillSections.length > 0) {\n      systemPrompt += `\\n\\n# Active Skills\\nApply the following behavioral instructions to your response:\\n\\n${skillSections.join(\"\\n\\n\")}`;\n    }\n  }\n\n  if (querySkillNames.length > 0) {\n    bus?.emit(BUS_EVENTS.SKILL_INJECT, { agent, skills: querySkillNames, phase: \"query\" });\n  }\n  bus?.emit(BUS_EVENTS.DELEGATE_START, { from, to: agent, query });\n\n  const childCtx: DelegationContext = {\n    chain: [...chain, agent],\n    depth: depth + 1,\n    events: parentCtx?.events,\n    abortSignal: parentCtx?.abortSignal,\n  };\n\n  const augmentedTools: Record<string, any> = {\n    ...registration.tools!,\n    [TOOL_NAMES.CLARIFY]: CLARIFY_TOOL,\n  };\n  if (!registration.disableMemoryTool) {\n    augmentedTools[TOOL_NAMES.MEMORY] = createMemoryTool(getDefaultMemoryStore(), agent);\n  }\n\n  // Invoke guard if present\n  if (registration.guard) {\n    emitStatus({ code: STATUS_CODES.GUARD_CHECK, message: \"Running pre-execution guard\", agent });\n    const guardResult = await registration.guard(query, agent);\n    if (!guardResult.allowed) {\n      bus?.emit(BUS_EVENTS.DELEGATE_END, {\n        from, to: agent, summary: `Blocked: ${guardResult.reason ?? \"guard rejected\"}`, error: true,\n      });\n      return errorResult(agent, query, `Guard blocked: ${guardResult.reason ?? \"query not allowed\"}`);\n    }\n  }\n\n  let augmentedSystem = systemPrompt + CLARIFY_PROMPT_SUFFIX;\n  if (!registration.disableMemoryTool) {\n    augmentedSystem += MEMORY_PROMPT_SUFFIX;\n  }\n\n  try {\n    bus?.emit(BUS_EVENTS.AGENT_START, { agent });\n    emitStatus({ code: STATUS_CODES.PROCESSING, message: \"Agent starting work\", agent });\n    const result = await delegationStore.run(childCtx, () =>\n      runAgent(ctx, { system: augmentedSystem, tools: augmentedTools, agentName: agent }, query)\n    );\n\n    bus?.emit(BUS_EVENTS.AGENT_END, { agent });\n    bus?.emit(BUS_EVENTS.DELEGATE_END, { from, to: agent, summary: result.response.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT) });\n\n    return {\n      agent,\n      query,\n      result,\n      ...(responseSkillNames.length > 0 && { responseSkills: responseSkillNames }),\n    };\n  } catch (err: unknown) {\n    const message = err instanceof Error ? err.message : String(err);\n    bus?.emit(BUS_EVENTS.AGENT_END, { agent, error: message.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT) });\n    bus?.emit(BUS_EVENTS.DELEGATE_END, { from, to: agent, summary: `Error: ${message.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT)}`, error: true });\n    return errorResult(agent, query, `Agent execution failed: ${message}`);\n  }\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/agents/run-agent.ts",
      "content": "import { generateText, stepCountIs } from \"ai\";\nimport { extractUsage } from \"../utils/ai-provider.js\";\nimport { getEventBus, getAbortSignal } from \"../utils/delegation-context.js\";\nimport { TOOL_NAMES } from \"../utils/constants.js\";\nimport { BUS_EVENTS } from \"../events/events.js\";\nimport { withResilience } from \"../utils/resilience.js\";\n\nconst BUILT_IN_TOOLS: Set<string> = new Set([TOOL_NAMES.CLARIFY, TOOL_NAMES.MEMORY]);\nimport type { ClarifyItem } from \"./execute-task.js\";\nimport type { PluginContext } from \"../types.js\";\n\ninterface AgentConfig {\n  system: string;\n  // AI SDK tool type is opaque and not directly expressible — `any` required here\n  tools: Record<string, any>;\n  agentName?: string;\n}\n\nexport async function runAgent(\n  ctx: PluginContext,\n  config: AgentConfig,\n  message: string,\n  model?: string,\n  maxSteps = ctx.defaultMaxSteps,\n) {\n  const startTime = performance.now();\n  const abortSignal = getAbortSignal();\n  const result = await withResilience({\n    fn: (overrideModel) => generateText({\n      model: ctx.getModel(overrideModel ?? model),\n      system: config.system,\n      prompt: message,\n      tools: config.tools,\n      stopWhen: stepCountIs(maxSteps),\n      abortSignal,\n    }),\n    ctx,\n    agent: config.agentName,\n    modelId: model,\n    abortSignal,\n  });\n\n  const toolsUsed = result.steps\n    .flatMap((step) => step.toolCalls)\n    .map((tc) => tc.toolName)\n    .filter((t) => !BUILT_IN_TOOLS.has(t));\n\n  const bus = getEventBus();\n  if (bus) {\n    for (const step of result.steps) {\n      for (const tc of step.toolCalls) {\n        if (!BUILT_IN_TOOLS.has(tc.toolName)) {\n          // AI SDK v6 ToolCall type doesn't expose `.input` directly\n          const tcInput = (tc as unknown as { input: Record<string, unknown> }).input;\n          bus.emit(BUS_EVENTS.TOOL_CALL, { agent: config.agentName, tool: tc.toolName, args: tcInput });\n        }\n      }\n      for (const tr of step.toolResults) {\n        if (!BUILT_IN_TOOLS.has(tr.toolName)) {\n          // AI SDK v6 ToolResult type doesn't expose `.output` directly\n          const trOutput = (tr as unknown as { output: unknown }).output;\n          bus.emit(BUS_EVENTS.TOOL_RESULT, { agent: config.agentName, tool: tr.toolName, result: trOutput });\n        }\n      }\n    }\n  }\n\n  const items: ClarifyItem[] = [];\n  for (const step of result.steps) {\n    for (const tc of step.toolCalls) {\n      if (tc.toolName === TOOL_NAMES.CLARIFY) {\n        // AI SDK v6 ToolCall type doesn't expose `.input` directly\n        const input = (tc as unknown as { input: { items?: ClarifyItem[]; questions?: Array<Record<string, unknown>> } }).input;\n        if (!input) continue;\n        if (input.items?.length) {\n          items.push(...input.items);\n        } else if (input.questions?.length) {\n          for (const q of input.questions) {\n            const text = (q.question ?? q.text ?? String(q)) as string;\n            const context = q.context as string | undefined;\n            items.push({\n              type: \"question\",\n              text,\n              ...(context ? { context } : {}),\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    response: result.text,\n    ...(items.length > 0 && { items }),\n    toolsUsed: [...new Set(toolsUsed)],\n    usage: extractUsage(result, startTime),\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/agents/orchestrator.ts",
      "content": "import { generateText, streamText, tool, stepCountIs } from \"ai\";\nimport { z } from \"zod\";\nimport { createSSEStream } from \"../streaming/sse-writer.js\";\nimport type { AgentRequest } from \"../types.js\";\nimport { extractUsage, extractStreamUsage, mergeUsage, type UsageInfo } from \"../utils/ai-provider.js\";\nimport { executeTask, type TaskResult } from \"./execute-task.js\";\nimport { generateConversationId } from \"../registry/handler-factories.js\";\nimport { getOrchestratorAgents, getEventBus, getAbortSignal, delegationStore } from \"../utils/delegation-context.js\";\nimport { registerRequest, cancelRequest, unregisterRequest } from \"../utils/request-registry.js\";\nimport { SSE_EVENTS, BUS_EVENTS, BUS_TO_SSE_MAP, FORWARDED_BUS_EVENTS, STATUS_CODES } from \"../events/events.js\";\nimport { writeStatus } from \"../events/emit-status.js\";\nimport { TOOL_NAMES, DEFAULTS } from \"../utils/constants.js\";\nimport { withResilience } from \"../utils/resilience.js\";\nimport { loadConversationWithCompaction } from \"../utils/conversation-helpers.js\";\nimport type { CardData } from \"../utils/card-registry.js\";\nimport type { CardRegistry } from \"../utils/card-registry.js\";\nimport type { AgentEventBus } from \"../events/agent-events.js\";\nimport type { PluginContext } from \"../types.js\";\nimport type { AgentRegistration } from \"../registry/agent-registry.js\";\n\nasync function executeTasksSettled(\n  ctx: PluginContext,\n  tasks: { agent: string; query: string; skills?: string[] }[],\n): Promise<TaskResult[]> {\n  const settled = await Promise.allSettled(\n    tasks.map((t) => executeTask(ctx, t.agent, t.query, t.skills))\n  );\n  return settled.map((s, i) => {\n    if (s.status === \"fulfilled\") return s.value;\n    return {\n      agent: tasks[i].agent,\n      query: tasks[i].query,\n      result: { response: `Task failed: ${(s.reason as Error)?.message ?? \"Unknown error\"}`, toolsUsed: [] },\n    };\n  });\n}\n\nexport const DEFAULT_ORCHESTRATOR_PROMPT = `You are an orchestrator agent that routes user queries to the appropriate specialist agent.\n\nWhen you receive a query:\n1. Analyze what the user is asking about\n2. Consider if any available skills would improve the response quality\n3. For simple, single-domain queries: use routeToAgent to delegate immediately\n4. For complex, multi-domain queries: use createTask for each sub-task (they will run in parallel)\n5. Synthesize the results into a coherent response\n\nGuidelines for choosing between routeToAgent and createTask:\n- Use routeToAgent when the query maps to a single agent or when tasks must be sequential\n- Use createTask when the query spans multiple independent domains that can run in parallel\n- You can mix both in a single response if needed\n\nGuidelines for skill selection:\n- Only attach skills when they clearly match the user's intent or phrasing\n- Don't attach skills when they would not meaningfully change the response\n- You may attach multiple skills if they complement each other\n- Each skill has a phase (query/response/both) — this is handled automatically, just select the right skills\n\nAlways use the routing tools - never answer domain questions directly.`;\n\nexport interface OrchestratorAgentConfig {\n  name: string;\n  description?: string;\n  systemPrompt?: string;\n  agents?: string[];\n  autonomous?: boolean;\n}\n\n// ── Serialized stream writer\ninterface StreamWriter {\n  write(event: string, data: Record<string, unknown>): Promise<void>;\n  flush(): Promise<void>;\n}\n\nfunction createStreamWriter(stream: { writeSSE: (msg: any) => Promise<void> }): StreamWriter {\n  let id = 0;\n  let chain = Promise.resolve();\n  return {\n    write(event: string, data: Record<string, unknown>) {\n      const p = chain.then(() => stream.writeSSE({ id: String(id++), event, data: JSON.stringify(data) }));\n      chain = p.catch(() => {});\n      return p;\n    },\n    flush() { return chain; },\n  };\n}\n\nfunction bridgeBusToStream(bus: AgentEventBus | undefined, writer: StreamWriter, cardRegistry: CardRegistry): { unsub: () => void; cards: CardData[] } {\n  const cards: CardData[] = [];\n  if (!bus) return { unsub: () => {}, cards };\n\n  const unsub = bus.subscribe((event) => {\n    if (!FORWARDED_BUS_EVENTS.has(event.type)) return;\n    const sseEvent = BUS_TO_SSE_MAP[event.type] ?? event.type;\n    let data = event.data;\n    if (event.type === BUS_EVENTS.TOOL_CALL && data.tool && !data.toolName) data = { ...data, toolName: data.tool };\n    if (event.type === BUS_EVENTS.TOOL_RESULT && data.tool && !data.toolName) data = { ...data, toolName: data.tool };\n    if (event.type === BUS_EVENTS.TOOL_RESULT) {\n      const rec = data as Record<string, unknown>;\n      const toolName = (rec.toolName ?? rec.tool) as string;\n      const result = rec.result;\n      const extracted = cardRegistry.extract(toolName, result);\n      cards.push(...extracted);\n    }\n    writer.write(sseEvent, data);\n  });\n\n  return { unsub, cards };\n}\n\n// ── Synthesis helpers\n\ninterface SynthesisSource {\n  label: string;\n  response: string;\n}\n\nfunction taskResultsToSources(results: TaskResult[]): SynthesisSource[] {\n  return results.map((r, i) => ({ label: `Task ${i + 1} (${r.agent})`, response: r.result.response }));\n}\n\nfunction buildSynthesisPrompt(sources: SynthesisSource[], userMessage: string): string {\n  const body = sources.map(s => `${s.label}:\\n${s.response}`).join(\"\\n\\n\");\n  return `Here are the results from the specialist agent(s):\\n\\n${body}\\n\\nPlease synthesize these results into a coherent, comprehensive response for the user's original query: \"${userMessage}\"`;\n}\n\nasync function synthesizeStreaming(opts: {\n  ctx: PluginContext; model: string | undefined; sources: SynthesisSource[];\n  userMessage: string; skillNames: string[]; writer: StreamWriter;\n  agentName: string; abortSignal?: AbortSignal;\n}): Promise<{ text: string; usage: UsageInfo }> {\n  const { ctx, model, sources, userMessage, skillNames, writer, agentName, abortSignal } = opts;\n  const synthesisSystem = await buildSynthesisContext(ctx, skillNames);\n  if (skillNames.length > 0) await writer.write(SSE_EVENTS.SKILL_INJECT, { agent: agentName, skills: skillNames, phase: \"response\" });\n  await writeStatus(writer, { code: STATUS_CODES.SYNTHESIZING, message: \"Combining results\", agent: agentName });\n  await writer.write(SSE_EVENTS.AGENT_THINK, { text: DEFAULTS.SYNTHESIS_MESSAGE });\n  const prompt = buildSynthesisPrompt(sources, userMessage);\n  const synthesisStart = performance.now();\n  const synthesisResult = streamText({ model: ctx.getModel(model), ...(synthesisSystem && { system: synthesisSystem }), prompt, abortSignal });\n  let fullText = \"\";\n  for await (const text of synthesisResult.textStream) { fullText += text; await writer.write(SSE_EVENTS.TEXT_DELTA, { text }); }\n  const synthesisUsage = await synthesisResult.usage;\n  return { text: fullText, usage: extractStreamUsage(synthesisUsage, synthesisStart) };\n}\n\nasync function synthesizeJson(opts: {\n  ctx: PluginContext; model: string | undefined; sources: SynthesisSource[];\n  userMessage: string; skillNames: string[]; agentName: string; bus?: AgentEventBus;\n}): Promise<{ text: string; usage: UsageInfo }> {\n  const { ctx, model, sources, userMessage, skillNames, agentName, bus } = opts;\n  const synthesisSystem = await buildSynthesisContext(ctx, skillNames);\n  if (skillNames.length > 0) bus?.emit(BUS_EVENTS.SKILL_INJECT, { agent: agentName, skills: skillNames, phase: \"response\" });\n  const prompt = buildSynthesisPrompt(sources, userMessage);\n  const synthesisStart = performance.now();\n  const synthesisResult = await withResilience({\n    fn: (overrideModel) => generateText({ model: ctx.getModel(overrideModel ?? model), ...(synthesisSystem && { system: synthesisSystem }), prompt }),\n    ctx, agent: agentName, modelId: model,\n  });\n  return { text: synthesisResult.text, usage: extractUsage(synthesisResult, synthesisStart) };\n}\n\n// ── Agent helpers\nfunction getRoutableAgents(ctx: PluginContext, allowedAgents?: string[]) {\n  const orchestrators = getOrchestratorAgents(ctx.agents);\n  return ctx.agents.list().filter((a) => {\n    if (orchestrators.has(a.name)) return false;\n    if (!a.tools || Object.keys(a.tools).length === 0) return false;\n    if (allowedAgents) return allowedAgents.includes(a.name);\n    return true;\n  });\n}\n\nfunction buildRoutingTool(ctx: PluginContext, allowedAgents?: string[]) {\n  const agents = getRoutableAgents(ctx, allowedAgents);\n  if (agents.length === 0) throw new Error(\"No routable agents available\");\n  const agentNames = agents.map((a) => a.name) as [string, ...string[]];\n\n  return tool({\n    description: \"Route a query to a specialist agent for immediate execution.\",\n    inputSchema: z.object({\n      agent: z.enum(agentNames).describe(\"The specialist agent to route to\"),\n      query: z.string().describe(\"The query to send to the agent\"),\n      skills: z.array(z.string()).optional().describe(\"Skill names to activate\"),\n    }),\n    execute: async ({ agent, query, skills }) => {\n      const taskResult = await executeTask(ctx, agent, query, skills);\n      return { ...taskResult.result, [DEFAULTS.RESPONSE_SKILLS_KEY]: taskResult.responseSkills ?? [] };\n    },\n  });\n}\n\nfunction buildCreateTaskTool(ctx: PluginContext, allowedAgents?: string[]) {\n  const agents = getRoutableAgents(ctx, allowedAgents);\n  if (agents.length === 0) throw new Error(\"No routable agents available\");\n  const agentNames = agents.map((a) => a.name) as [string, ...string[]];\n\n  return tool({\n    description: \"Create a sub-task to be delegated to a specialist agent. Tasks run in parallel.\",\n    inputSchema: z.object({\n      agent: z.enum(agentNames).describe(\"The specialist agent\"),\n      query: z.string().describe(\"The specific query\"),\n      skills: z.array(z.string()).optional().describe(\"Skill names to activate\"),\n    }),\n  });\n}\n\nasync function buildSystemPrompt(ctx: PluginContext, basePrompt: string, allowedAgents?: string[]) {\n  const agents = getRoutableAgents(ctx, allowedAgents);\n  const agentList = agents.map((a) => `- ${a.name}: ${a.description}`).join(\"\\n\");\n  let prompt = `${basePrompt}\\n\\nAvailable agents:\\n${agentList}`;\n  const skillSummaries = await ctx.storage.skills.getSkillSummaries();\n  prompt += `\\n\\nAvailable skills (pass skill names in the \"skills\" parameter when routing):\\n${skillSummaries}`;\n  return prompt;\n}\n\nfunction collectTasksFromSteps(steps: Array<{ toolCalls: Array<{ toolName: string }> }>): { agent: string; query: string; skills?: string[] }[] {\n  const tasks: { agent: string; query: string; skills?: string[] }[] = [];\n  for (const step of steps) {\n    for (const tc of step.toolCalls) {\n      // AI SDK v6 ToolCall type doesn't expose `.input` directly\n      const input = (tc as unknown as { input: Record<string, unknown> }).input;\n      if (tc.toolName === TOOL_NAMES.CREATE_TASK && input) {\n        const typed = input as { agent?: string; query?: string; skills?: string[] };\n        if (typed.agent && typed.query) tasks.push({ agent: typed.agent, query: typed.query, skills: typed.skills });\n      }\n    }\n  }\n  return tasks;\n}\n\nfunction collectResponseSkills(results: TaskResult[]): string[] {\n  const all = results.flatMap((r) => r.responseSkills ?? []);\n  return [...new Set(all)];\n}\n\nasync function buildSynthesisContext(ctx: PluginContext, skillNames: string[]): Promise<string | undefined> {\n  if (skillNames.length === 0) return undefined;\n  const sections: string[] = [];\n  for (const name of [...new Set(skillNames)]) {\n    const skill = await ctx.storage.skills.getSkill(name);\n    if (skill) sections.push(`### ${skill.name}\\n${skill.content}`);\n  }\n  if (sections.length === 0) return undefined;\n  return `# Active Skills\\nApply the following behavioral instructions to your response:\\n\\n${sections.join(\"\\n\\n\")}`;\n}\n\n// ── SSE Handler ──────────────────────────────────────\nfunction buildSseHandler(ctx: PluginContext, agentName: string, allowedAgents?: string[], defaultAutonomous = true) {\n  return async (req: AgentRequest, { systemPrompt, memoryContext }: { systemPrompt: string; memoryContext?: string }) => {\n    const body = await req.json<any>();\n    const { message, conversationId: cid, model, planMode, approvedPlan, autonomous: reqAutonomous } = body;\n    const convId = generateConversationId(cid);\n    const autonomous = reqAutonomous ?? defaultAutonomous;\n    const overallStart = performance.now();\n\n    const controller = registerRequest(convId);\n    const abortSignal = controller.signal;\n    req.raw.signal.addEventListener(\"abort\", () => cancelRequest(convId));\n    const parentCtx = delegationStore.getStore();\n    const delCtx = { ...parentCtx!, abortSignal };\n\n    let system = await buildSystemPrompt(ctx, systemPrompt, allowedAgents);\n    if (memoryContext) system += `\\n\\n## Memory Context\\n${memoryContext}`;\n\n    let historyMessages: Array<{ role: \"user\" | \"assistant\"; content: string }> | undefined;\n    if (cid) {\n      historyMessages = await loadConversationWithCompaction(ctx, cid, message);\n    }\n\n    async function saveAssistantResponse(text: string, cards?: CardData[]) {\n      if (cid && text) {\n        await ctx.storage.conversations.append(cid, { role: \"assistant\", content: text, timestamp: new Date().toISOString(), ...(cards?.length ? { metadata: { cards } } : {}) });\n      }\n    }\n\n    // approvedPlan shortcut\n    if (approvedPlan && Array.isArray(approvedPlan) && approvedPlan.length > 0) {\n      return createSSEStream(async (writer) => {\n        return delegationStore.run(delCtx, async () => {\n          const swriter = createStreamWriter(writer);\n          const bus = getEventBus();\n          const { unsub, cards: collectedCards } = bridgeBusToStream(bus, swriter, ctx.cards);\n          await swriter.write(SSE_EVENTS.SESSION_START, { conversationId: convId });\n          try {\n            await swriter.write(SSE_EVENTS.AGENT_START, { agent: agentName });\n            await writeStatus(swriter, { code: STATUS_CODES.EXECUTING_TASKS, message: \"Executing approved plan tasks\", agent: agentName });\n            const results = await executeTasksSettled(ctx, approvedPlan.map((task: any) => ({ agent: task.agent, query: task.query, skills: task.skills })));\n            await swriter.flush();\n            const responseSkills = collectResponseSkills(results);\n            const sources = taskResultsToSources(results);\n            const { text: fullText, usage: synthUsageInfo } = await synthesizeStreaming({\n              ctx, model, sources, userMessage: message, skillNames: responseSkills,\n              writer: swriter, agentName, abortSignal,\n            });\n            await saveAssistantResponse(fullText, collectedCards);\n            const subAgentUsages = results.map((r) => r.result.usage).filter((u): u is UsageInfo => !!u);\n            const totalUsage = mergeUsage(...subAgentUsages, synthUsageInfo);\n            totalUsage.durationMs = Math.round(performance.now() - overallStart);\n            await swriter.write(SSE_EVENTS.AGENT_END, { agent: agentName });\n            await swriter.write(SSE_EVENTS.DONE, { toolsUsed: [...new Set(results.flatMap((r) => r.result.toolsUsed))], conversationId: convId, tasks: results.map((r) => ({ agent: r.agent, query: r.query, summary: r.result.response.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT) })), usage: totalUsage });\n          } catch (err: unknown) {\n            const message = err instanceof Error ? err.message : String(err);\n            const errName = err instanceof Error ? err.name : undefined;\n            if (errName === \"AbortError\" || abortSignal?.aborted) {\n              await swriter.write(SSE_EVENTS.CANCELLED, { conversationId: convId });\n            } else {\n              console.error(`[orchestrator:${agentName}] approvedPlan SSE error:`, message);\n              await swriter.write(SSE_EVENTS.ERROR, { conversationId: convId, error: message });\n            }\n          } finally { unregisterRequest(convId); unsub(); }\n        });\n      }, abortSignal);\n    }\n\n    // AI SDK tool type is opaque and not directly expressible — `any` required here\n    const tools: Record<string, any> = {};\n    if (planMode) {\n      tools[TOOL_NAMES.CREATE_TASK] = buildCreateTaskTool(ctx, allowedAgents);\n    } else {\n      tools[TOOL_NAMES.ROUTE_TO_AGENT] = buildRoutingTool(ctx, allowedAgents);\n      tools[TOOL_NAMES.CREATE_TASK] = buildCreateTaskTool(ctx, allowedAgents);\n    }\n\n    return createSSEStream(async (writer) => {\n      return delegationStore.run(delCtx, async () => {\n        const swriter = createStreamWriter(writer);\n        const bus = getEventBus();\n        const { unsub, cards: collectedCards } = bridgeBusToStream(bus, swriter, ctx.cards);\n        await swriter.write(SSE_EVENTS.SESSION_START, { conversationId: convId });\n        try {\n          await swriter.write(SSE_EVENTS.AGENT_START, { agent: agentName });\n          await writeStatus(swriter, { code: STATUS_CODES.THINKING, message: \"Analyzing query and routing\", agent: agentName });\n          const planStart = performance.now();\n          const planResult = await withResilience({\n            fn: (overrideModel) => generateText({\n              model: ctx.getModel(overrideModel ?? model), system,\n              ...(historyMessages ? { messages: historyMessages.map(m => ({ role: m.role, content: m.content })) } : { prompt: message }),\n              tools, stopWhen: stepCountIs(ctx.defaultMaxSteps), abortSignal,\n            }),\n            ctx, agent: agentName, modelId: model, abortSignal,\n          });\n          const planUsage = extractUsage(planResult, planStart);\n          await swriter.flush();\n\n          // Reactive clarification check\n          if (!autonomous) {\n            for (const step of planResult.steps) {\n              for (const tr of step.toolResults) {\n                if (tr.toolName === TOOL_NAMES.ROUTE_TO_AGENT) {\n                  const output = (tr as any).output;\n                  if (output?.items?.length) {\n                    const agent = (planResult.steps.flatMap((s) => s.toolCalls).find((tc) => tc.toolName === TOOL_NAMES.ROUTE_TO_AGENT)?.input as any)?.agent;\n                    const taggedItems = output.items.map((item: any) => ({ ...item, agent }));\n                    await swriter.write(SSE_EVENTS.ASK_USER, { items: taggedItems });\n                    await swriter.write(SSE_EVENTS.AGENT_END, { agent: agentName });\n                    const subAgentUsage = output?.usage as UsageInfo | undefined;\n                    const totalUsage = subAgentUsage ? mergeUsage(planUsage, subAgentUsage) : { ...planUsage };\n                    totalUsage.durationMs = Math.round(performance.now() - overallStart);\n                    await swriter.write(SSE_EVENTS.DONE, { toolsUsed: [TOOL_NAMES.ROUTE_TO_AGENT], conversationId: convId, awaitingResponse: true, items: taggedItems, usage: totalUsage });\n                    return;\n                  }\n                }\n              }\n            }\n          }\n\n          const tasks = collectTasksFromSteps(planResult.steps);\n\n          if (tasks.length > 0) {\n            await writeStatus(swriter, { code: STATUS_CODES.PLANNING, message: \"Building task plan\", agent: agentName });\n            await swriter.write(SSE_EVENTS.AGENT_PLAN, { tasks });\n            if (!autonomous) {\n              await swriter.write(SSE_EVENTS.AGENT_END, { agent: agentName });\n              await swriter.write(SSE_EVENTS.DONE, { toolsUsed: [TOOL_NAMES.CREATE_TASK], conversationId: convId, awaitingApproval: true, tasks, usage: { ...planUsage, durationMs: Math.round(performance.now() - overallStart) } });\n              return;\n            }\n            await writeStatus(swriter, { code: STATUS_CODES.EXECUTING_TASKS, message: \"Executing parallel tasks\", agent: agentName });\n            const results = await executeTasksSettled(ctx, tasks);\n            await swriter.flush();\n            const responseSkills = collectResponseSkills(results);\n            const sources = taskResultsToSources(results);\n            const { text: fullText, usage: synthUsageInfo } = await synthesizeStreaming({\n              ctx, model, sources, userMessage: message, skillNames: responseSkills,\n              writer: swriter, agentName, abortSignal,\n            });\n            await saveAssistantResponse(fullText, collectedCards);\n            const subAgentUsages = results.map((r) => r.result.usage).filter((u): u is UsageInfo => !!u);\n            const totalUsage = mergeUsage(planUsage, ...subAgentUsages, synthUsageInfo);\n            totalUsage.durationMs = Math.round(performance.now() - overallStart);\n            await swriter.write(SSE_EVENTS.AGENT_END, { agent: agentName });\n            await swriter.write(SSE_EVENTS.DONE, { toolsUsed: [...new Set(results.flatMap((r) => r.result.toolsUsed))], conversationId: convId, tasks: results.map((r) => ({ agent: r.agent, query: r.query, summary: r.result.response.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT) })), usage: totalUsage });\n            return;\n          }\n\n          // Direct mode\n          const routeResults = planResult.steps.flatMap((step) => step.toolResults).filter((tr) => tr.toolName === TOOL_NAMES.ROUTE_TO_AGENT);\n          if (routeResults.length > 0) {\n            const responseSkills = [...new Set(routeResults.flatMap((tr) => (tr as any).output?.[DEFAULTS.RESPONSE_SKILLS_KEY] ?? []))];\n            const sources: SynthesisSource[] = routeResults.map((tr, i) => {\n              const output = (tr as any).output;\n              const resolved = output ?? (tr as any).result;\n              const response = resolved?.response ?? \"\";\n              return { label: `Result ${i + 1}`, response };\n            });\n            const { text: fullText, usage: synthUsageInfo } = await synthesizeStreaming({\n              ctx, model, sources, userMessage: message, skillNames: responseSkills,\n              writer: swriter, agentName, abortSignal,\n            });\n            await saveAssistantResponse(fullText, collectedCards);\n            const routeToolsUsed = routeResults.flatMap((tr) => (tr as any).output?.toolsUsed ?? []);\n            const subAgentUsages = routeResults.map((tr) => (tr as any).output?.usage).filter((u): u is UsageInfo => !!u);\n            const totalUsage = mergeUsage(planUsage, ...subAgentUsages, synthUsageInfo);\n            totalUsage.durationMs = Math.round(performance.now() - overallStart);\n            await swriter.write(SSE_EVENTS.AGENT_END, { agent: agentName });\n            await swriter.write(SSE_EVENTS.DONE, { toolsUsed: [...new Set([TOOL_NAMES.ROUTE_TO_AGENT, ...routeToolsUsed])], conversationId: convId, usage: totalUsage });\n          } else {\n            if (planResult.text) { await swriter.write(SSE_EVENTS.TEXT_DELTA, { text: planResult.text }); await saveAssistantResponse(planResult.text, collectedCards); }\n            await swriter.write(SSE_EVENTS.AGENT_END, { agent: agentName });\n            await swriter.write(SSE_EVENTS.DONE, { toolsUsed: [...new Set(planResult.steps.flatMap((step) => step.toolCalls).map((tc) => tc.toolName))], conversationId: convId, usage: { ...planUsage, durationMs: Math.round(performance.now() - overallStart) } });\n          }\n        } catch (err: unknown) {\n          const message = err instanceof Error ? err.message : String(err);\n          const errName = err instanceof Error ? err.name : undefined;\n          if (errName === \"AbortError\" || abortSignal.aborted) {\n            await swriter.write(SSE_EVENTS.CANCELLED, { conversationId: convId });\n          } else {\n            console.error(`[orchestrator:${agentName}] SSE error:`, message);\n            await swriter.write(SSE_EVENTS.ERROR, { conversationId: convId, error: message });\n          }\n        } finally { unregisterRequest(convId); unsub(); }\n      });\n    }, abortSignal);\n  };\n}\n\n// ── JSON handler\nfunction buildJsonHandler(ctx: PluginContext, agentName: string, allowedAgents?: string[], defaultAutonomous = true) {\n  return async (req: AgentRequest, { systemPrompt, memoryContext }: { systemPrompt: string; memoryContext?: string }) => {\n    const body = await req.json<any>();\n    const { message, conversationId: cid, model, approvedPlan, autonomous: reqAutonomous } = body;\n    const autonomous = reqAutonomous ?? defaultAutonomous;\n\n    if (approvedPlan && Array.isArray(approvedPlan) && approvedPlan.length > 0) {\n      const overallStart = performance.now();\n      const results = await executeTasksSettled(ctx, approvedPlan.map((task: any) => ({ agent: task.agent, query: task.query, skills: task.skills })));\n      const responseSkills = collectResponseSkills(results);\n      const sources = taskResultsToSources(results);\n      const { text, usage: synthUsage } = await synthesizeJson({\n        ctx, model, sources, userMessage: message, skillNames: responseSkills,\n        agentName, bus: getEventBus(),\n      });\n      const subAgentUsages = results.map((r) => r.result.usage).filter((u): u is UsageInfo => !!u);\n      const totalUsage = mergeUsage(...subAgentUsages, synthUsage);\n      totalUsage.durationMs = Math.round(performance.now() - overallStart);\n      return new Response(JSON.stringify({ response: text, toolsUsed: [...new Set(results.flatMap((r) => r.result.toolsUsed))], tasks: results.map((r) => ({ agent: r.agent, query: r.query, summary: r.result.response.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT) })), conversationId: generateConversationId(cid), usage: totalUsage }), {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    // Build system prompt including agent+skill summaries\n    let system = await buildSystemPrompt(ctx, systemPrompt, allowedAgents);\n    if (memoryContext) system += `\\n\\n## Memory Context\\n${memoryContext}`;\n\n    const startTime = performance.now();\n    const routeToAgentTool = buildRoutingTool(ctx, allowedAgents);\n    const createTaskTool = buildCreateTaskTool(ctx, allowedAgents);\n\n    const result = await withResilience({\n      fn: (overrideModel) => generateText({\n        model: ctx.getModel(overrideModel ?? model), system, prompt: message,\n        tools: { [TOOL_NAMES.ROUTE_TO_AGENT]: routeToAgentTool, [TOOL_NAMES.CREATE_TASK]: createTaskTool },\n        stopWhen: stepCountIs(ctx.defaultMaxSteps), abortSignal: getAbortSignal(),\n      }),\n      ctx, agent: agentName, modelId: model, abortSignal: getAbortSignal(),\n    });\n\n    // Handle deferred createTask calls\n    const tasks = collectTasksFromSteps(result.steps);\n    if (tasks.length > 0) {\n      const results = await executeTasksSettled(ctx, tasks);\n      const responseSkills = collectResponseSkills(results);\n      const sources = taskResultsToSources(results);\n      const { text, usage: synthUsage } = await synthesizeJson({\n        ctx, model, sources, userMessage: message, skillNames: responseSkills,\n        agentName,\n      });\n      const orchestratorUsage = extractUsage(result, startTime);\n      const subAgentUsages = results.map((r) => r.result.usage).filter((u): u is UsageInfo => !!u);\n      const totalUsage = mergeUsage(orchestratorUsage, ...subAgentUsages, synthUsage);\n      totalUsage.durationMs = Math.round(performance.now() - startTime);\n      return new Response(JSON.stringify({ response: text, toolsUsed: [...new Set(results.flatMap((r) => r.result.toolsUsed))], agentsUsed: [...new Set(results.map((r) => r.agent))], tasks: results.map((r) => ({ agent: r.agent, query: r.query, summary: r.result.response.slice(0, DEFAULTS.SUMMARY_LENGTH_LIMIT) })), conversationId: generateConversationId(cid), usage: totalUsage }), {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    // Direct routeToAgent path\n    const orchestratorUsage = extractUsage(result, startTime);\n    const routeResultUsages = result.steps.flatMap((step) => step.toolResults).filter((tr) => tr.toolName === TOOL_NAMES.ROUTE_TO_AGENT).map((tr) => (tr as any).output?.usage).filter((u): u is UsageInfo => !!u);\n    const toolsUsed = result.steps.flatMap((step) => step.toolCalls).map((tc) => tc.toolName);\n    const agentsUsed = result.steps.flatMap((step) => step.toolCalls).map((tc) => (tc as any).input).filter((input): input is { agent: string } => !!input?.agent).map((args) => args.agent);\n\n    return new Response(JSON.stringify({\n      response: result.text,\n      toolsUsed: [...new Set(toolsUsed)],\n      agentsUsed: [...new Set(agentsUsed)],\n      conversationId: generateConversationId(cid),\n      usage: routeResultUsages.length > 0 ? mergeUsage(orchestratorUsage, ...routeResultUsages) : orchestratorUsage,\n    }), {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  };\n}\n\n/**\n * Factory: creates and registers an orchestrator agent on the given plugin context.\n * Returns the AgentRegistration for further customization.\n */\nexport function createOrchestratorAgent(ctx: PluginContext, config: OrchestratorAgentConfig): AgentRegistration {\n  const {\n    name,\n    description = \"Unified orchestrator agent that routes queries directly or creates parallel task plans\",\n    systemPrompt = DEFAULT_ORCHESTRATOR_PROMPT,\n    agents,\n    autonomous = true,\n  } = config;\n\n  const registration: AgentRegistration = {\n    name,\n    description,\n    toolNames: [TOOL_NAMES.ROUTE_TO_AGENT, TOOL_NAMES.CREATE_TASK],\n    defaultFormat: \"sse\",\n    defaultSystem: systemPrompt,\n    isOrchestrator: true,\n    agents,\n    sseHandler: buildSseHandler(ctx, name, agents, autonomous),\n    jsonHandler: buildJsonHandler(ctx, name, agents, autonomous),\n  };\n\n  ctx.agents.register(registration);\n  return registration;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/agents/memory-tool.ts",
      "content": "import { tool } from \"ai\";\nimport { z } from \"zod\";\nimport type { MemoryStore } from \"../storage/interfaces.js\";\nimport { createInMemoryMemoryStore } from \"../storage/in-memory/memory-store.js\";\n\nlet defaultStore: MemoryStore | null = null;\n\n/** Returns the singleton default MemoryStore, lazy-creating an in-memory store on first call. */\nexport function getDefaultMemoryStore(): MemoryStore {\n  if (!defaultStore) {\n    defaultStore = createInMemoryMemoryStore();\n  }\n  return defaultStore;\n}\n\n/** Replaces the default MemoryStore (called by plugin.ts when config.memoryStore is provided). */\nexport function setDefaultMemoryStore(store: MemoryStore): void {\n  defaultStore = store;\n}\n\nconst memoryInputSchema = z.object({\n  action: z.enum([\"get\", \"set\", \"list\", \"delete\"]),\n  key: z.string().optional().describe(\"Required for get, set, and delete actions\"),\n  value: z.string().optional().describe(\"Required for set action — the value to store\"),\n  context: z.string().optional().describe(\"Optional context about why this was stored (set action only)\"),\n  namespace: z.string().optional().describe(\"Override the default namespace\"),\n});\n\n/**\n * Creates the built-in `_memory` tool bound to a specific store and default namespace.\n * The namespace defaults to the agent name but can be overridden per-call.\n */\nexport function createMemoryTool(store: MemoryStore, defaultNamespace: string) {\n  return tool({\n    description:\n      \"Store and retrieve information across conversations. \" +\n      \"Actions: set (save key-value), get (retrieve by key), list (show all entries), delete (remove by key). \" +\n      \"Use to remember user preferences, intermediate results, or important facts.\",\n    inputSchema: memoryInputSchema,\n    execute: async (input) => {\n      const ns = input.namespace ?? defaultNamespace;\n\n      switch (input.action) {\n        case \"get\": {\n          const key = input.key ?? \"\";\n          const entry = await store.getEntry(ns, key);\n          if (!entry) return { found: false, key, namespace: ns };\n          return { found: true, key: entry.key, value: entry.value, context: entry.context, namespace: ns };\n        }\n        case \"set\": {\n          const key = input.key ?? \"\";\n          const value = input.value ?? \"\";\n          const entry = await store.saveEntry(ns, key, value, input.context);\n          return { saved: true, key: entry.key, namespace: ns };\n        }\n        case \"list\": {\n          const entries = await store.listEntries(ns);\n          return {\n            namespace: ns,\n            count: entries.length,\n            entries: entries.map((e) => ({ key: e.key, value: e.value, context: e.context })),\n          };\n        }\n        case \"delete\": {\n          const key = input.key ?? \"\";\n          const deleted = await store.deleteEntry(ns, key);\n          return { deleted, key, namespace: ns };\n        }\n        default: {\n          const _exhaustive: never = input.action;\n          return { error: `Unknown action: ${_exhaustive}` };\n        }\n      }\n    },\n  });\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/ai-provider.ts",
      "content": "export interface UsageInfo {\n  inputTokens: number;\n  outputTokens: number;\n  totalTokens: number;\n  cost: number | null;\n  durationMs: number;\n}\n\n/**\n * Extract usage, cost, and timing from an AI SDK v6 result.\n * - Prefers `totalUsage` (aggregated across steps) over `usage` (last step only)\n * - Extracts cost from each step's `usage.raw.cost` (OpenRouter-specific)\n * - Requires `startTime` from `performance.now()` to compute duration\n */\nexport function extractUsage(\n  result: { totalUsage?: any; usage?: any; steps?: any[] },\n  startTime: number,\n): UsageInfo {\n  const u = result.totalUsage ?? result.usage;\n  const inputTokens = u?.inputTokens ?? 0;\n  const outputTokens = u?.outputTokens ?? 0;\n  const totalTokens = u?.totalTokens ?? (inputTokens + outputTokens);\n  const durationMs = Math.round(performance.now() - startTime);\n\n  let cost: number | null = null;\n  if (result.steps && result.steps.length > 0) {\n    let total = 0;\n    let found = false;\n    for (const step of result.steps) {\n      const stepCost = step.usage?.raw?.cost;\n      if (typeof stepCost === \"number\") {\n        total += stepCost;\n        found = true;\n      }\n    }\n    if (found) cost = total;\n  } else {\n    const rawCost = u?.raw?.cost;\n    if (typeof rawCost === \"number\") cost = rawCost;\n  }\n\n  return { inputTokens, outputTokens, totalTokens, cost, durationMs };\n}\n\n/**\n * Build a UsageInfo from a streaming result's awaited `usage` promise.\n */\nexport function extractStreamUsage(\n  usage: { inputTokens?: number; outputTokens?: number; totalTokens?: number; raw?: { cost?: number } } | undefined,\n  startTime: number,\n): UsageInfo {\n  const inputTokens = usage?.inputTokens ?? 0;\n  const outputTokens = usage?.outputTokens ?? 0;\n  const totalTokens = usage?.totalTokens ?? (inputTokens + outputTokens);\n  const rawCost = usage?.raw?.cost;\n\n  return {\n    inputTokens,\n    outputTokens,\n    totalTokens,\n    cost: typeof rawCost === \"number\" ? rawCost : null,\n    durationMs: Math.round(performance.now() - startTime),\n  };\n}\n\n/**\n * Merge multiple UsageInfo objects into one (for task agent aggregation).\n */\nexport function mergeUsage(...usages: UsageInfo[]): UsageInfo {\n  const merged: UsageInfo = {\n    inputTokens: 0,\n    outputTokens: 0,\n    totalTokens: 0,\n    cost: null,\n    durationMs: 0,\n  };\n\n  for (const u of usages) {\n    merged.inputTokens += u.inputTokens;\n    merged.outputTokens += u.outputTokens;\n    merged.totalTokens += u.totalTokens;\n    if (u.cost !== null) {\n      merged.cost = (merged.cost ?? 0) + u.cost;\n    }\n    if (u.durationMs > merged.durationMs) {\n      merged.durationMs = u.durationMs;\n    }\n  }\n\n  return merged;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/resilience.ts",
      "content": "import type { PluginContext } from \"../types.js\";\nimport { emitStatus } from \"../events/emit-status.js\";\nimport { STATUS_CODES } from \"../events/events.js\";\n\ninterface ResilienceOptions<T> {\n  /** The LLM call to wrap. Receives an optional override model ID. */\n  fn: (modelId?: string) => Promise<T>;\n  /** Plugin context — reads resilience config from ctx.config.resilience */\n  ctx: PluginContext;\n  /** Agent name for fallback context */\n  agent?: string;\n  /** Current model ID */\n  modelId?: string;\n  /** AbortSignal to respect cancellation */\n  abortSignal?: AbortSignal;\n}\n\nconst RETRYABLE_STATUS_CODES = new Set([429, 500, 502, 503, 504]);\nconst NON_RETRYABLE_STATUS_CODES = new Set([400, 401, 403, 404, 422]);\n\n/**\n * Classifies whether an error is retryable.\n * Retryable: 429, 500-504, timeouts, network errors, \"overloaded\"/\"capacity\".\n * Not retryable: AbortError, auth errors (401/403), validation errors (400/422).\n */\nexport function isRetryableError(error: unknown): boolean {\n  if (!(error instanceof Error)) return false;\n\n  // Never retry abort\n  if (error.name === \"AbortError\") return false;\n\n  const message = error.message.toLowerCase();\n\n  // Check for status codes in the error\n  const statusMatch = message.match(/\\b(\\d{3})\\b/);\n  if (statusMatch) {\n    const status = Number(statusMatch[1]);\n    if (RETRYABLE_STATUS_CODES.has(status)) return true;\n    // Non-retryable status codes\n    if (NON_RETRYABLE_STATUS_CODES.has(status)) return false;\n  }\n\n  // Check for status property on error object\n  const errRecord = error as unknown as Record<string, unknown>;\n  const statusProp = errRecord.status ?? errRecord.statusCode;\n  if (typeof statusProp === \"number\") {\n    if (RETRYABLE_STATUS_CODES.has(statusProp)) return true;\n    if (NON_RETRYABLE_STATUS_CODES.has(statusProp)) return false;\n  }\n\n  // Timeout and network errors\n  if (\n    message.includes(\"timeout\") ||\n    message.includes(\"timed out\") ||\n    message.includes(\"econnreset\") ||\n    message.includes(\"econnrefused\") ||\n    message.includes(\"network\") ||\n    message.includes(\"fetch failed\") ||\n    message.includes(\"socket hang up\")\n  ) {\n    return true;\n  }\n\n  // Provider capacity errors\n  if (message.includes(\"overloaded\") || message.includes(\"capacity\")) {\n    return true;\n  }\n\n  // Rate limit keywords\n  if (message.includes(\"rate limit\") || message.includes(\"too many requests\")) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction computeDelay(attempt: number, baseDelayMs: number, maxDelayMs: number, jitterFactor: number): number {\n  const exponential = Math.min(baseDelayMs * Math.pow(2, attempt), maxDelayMs);\n  const jitter = exponential * jitterFactor * Math.random();\n  return exponential + jitter;\n}\n\nfunction sleep(ms: number, signal?: AbortSignal): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(Object.assign(new Error(\"Aborted\"), { name: \"AbortError\" }));\n      return;\n    }\n    const timer = setTimeout(resolve, ms);\n    signal?.addEventListener(\"abort\", () => {\n      clearTimeout(timer);\n      reject(Object.assign(new Error(\"Aborted\"), { name: \"AbortError\" }));\n    }, { once: true });\n  });\n}\n\n/**\n * Generic retry wrapper for LLM calls with exponential backoff and fallback.\n *\n * Reads config from `ctx.config.resilience`. On retryable errors, retries up to\n * `maxRetries` with exponential backoff + jitter. When retries exhaust, calls\n * `onFallback()` if provided. If fallback returns a model ID, tries once more.\n */\nexport async function withResilience<T>(opts: ResilienceOptions<T>): Promise<T> {\n  const { fn, ctx, agent, modelId, abortSignal } = opts;\n  const config = ctx.config.resilience;\n\n  const maxRetries = config?.maxRetries ?? 3;\n  const baseDelayMs = config?.baseDelayMs ?? 1000;\n  const maxDelayMs = config?.maxDelayMs ?? 30000;\n  const jitterFactor = config?.jitterFactor ?? 0.2;\n  const onFallback = config?.onFallback;\n\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error: unknown) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Never retry aborts\n      if (lastError.name === \"AbortError\" || abortSignal?.aborted) {\n        throw lastError;\n      }\n\n      // Don't retry non-retryable errors\n      if (!isRetryableError(lastError)) {\n        throw lastError;\n      }\n\n      // Last attempt before fallback\n      if (attempt === maxRetries) {\n        break;\n      }\n\n      const delay = computeDelay(attempt, baseDelayMs, maxDelayMs, jitterFactor);\n      emitStatus({ code: STATUS_CODES.RETRYING, message: `Retrying (attempt ${attempt + 1}/${maxRetries})`, agent, metadata: { attempt: attempt + 1, maxRetries, delay } });\n      await sleep(delay, abortSignal);\n    }\n  }\n\n  // Retries exhausted — try fallback\n  if (onFallback && lastError) {\n    emitStatus({ code: STATUS_CODES.FALLBACK, message: \"Switching to fallback model\", agent, metadata: { currentModel: modelId ?? \"default\" } });\n    const fallbackModel = await onFallback({\n      agent,\n      currentModel: modelId ?? \"default\",\n      retryCount: maxRetries,\n      error: lastError,\n    });\n\n    if (fallbackModel) {\n      return await fn(fallbackModel);\n    }\n  }\n\n  throw lastError!;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/conversation-helpers.ts",
      "content": "import { needsCompaction, compactConversation } from \"./compaction.js\";\nimport { emitStatus } from \"../events/emit-status.js\";\nimport { STATUS_CODES } from \"../events/events.js\";\nimport type { PluginContext } from \"../types.js\";\n\n/**\n * Load conversation history with optional auto-compaction.\n *\n * - Loads the conversation from storage\n * - If auto-compaction is enabled and threshold exceeded, compacts then reloads\n * - Appends the new user message to the store\n * - Returns the history messages array, or undefined if conversation not found\n */\nexport async function loadConversationWithCompaction(\n  ctx: PluginContext,\n  conversationId: string,\n  newUserMessage: string,\n): Promise<Array<{ role: \"user\" | \"assistant\"; content: string }> | undefined> {\n  emitStatus({ code: STATUS_CODES.LOADING_CONTEXT, message: \"Loading conversation history\", metadata: { conversationId } });\n  let conv = await ctx.storage.conversations.get(conversationId);\n  if (!conv) return undefined;\n\n  // Auto-compact if enabled and threshold exceeded\n  const compactionConfig = ctx.config.compaction;\n  if (compactionConfig?.enabled !== false && compactionConfig && needsCompaction(conv, compactionConfig.threshold)) {\n    await compactConversation(ctx, conversationId);\n    conv = await ctx.storage.conversations.get(conversationId);\n    if (!conv) return undefined;\n  }\n\n  // Append user message\n  await ctx.storage.conversations.append(conversationId, {\n    role: \"user\",\n    content: newUserMessage,\n    timestamp: new Date().toISOString(),\n  });\n\n  return [\n    ...conv.messages.map((m: { role: \"user\" | \"assistant\"; content: string }) => ({ role: m.role, content: m.content })),\n    { role: \"user\" as const, content: newUserMessage },\n  ];\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/compaction.ts",
      "content": "import { generateText } from \"ai\";\nimport { withResilience } from \"./resilience.js\";\nimport { DEFAULTS } from \"./constants.js\";\nimport { emitStatus } from \"../events/emit-status.js\";\nimport { STATUS_CODES } from \"../events/events.js\";\nimport type { PluginContext } from \"../types.js\";\nimport type { Conversation, ConversationMessage } from \"../storage/interfaces.js\";\n\nexport const COMPACTION_METADATA_KEY = \"_compaction\";\n\nconst DEFAULT_COMPACTION_PROMPT = `You are a conversation summarizer. Given the following conversation messages, create a concise but comprehensive summary that preserves:\n- Key facts, decisions, and outcomes\n- User preferences and context established\n- Important tool results and their implications\n- Any ongoing tasks or commitments\n\nOutput ONLY the summary text, no preamble or formatting.`;\n\nexport interface CompactionResult {\n  summary: string;\n  summarizedCount: number;\n  preservedCount: number;\n  newMessageCount: number;\n}\n\n/**\n * Check if a conversation exceeds the compaction threshold.\n */\nexport function needsCompaction(conversation: Conversation, threshold?: number): boolean {\n  const limit = threshold ?? DEFAULTS.COMPACTION_THRESHOLD;\n  return conversation.messages.length > limit;\n}\n\nfunction formatMessagesForSummary(messages: ConversationMessage[]): string {\n  return messages\n    .map((m) => {\n      const prefix = m.metadata?.[COMPACTION_METADATA_KEY] ? \"[Previous Summary]\" : m.role;\n      return `${prefix}: ${m.content}`;\n    })\n    .join(\"\\n\\n\");\n}\n\n/**\n * Compact a conversation by summarizing older messages with an LLM call.\n * Preserves the most recent N messages as-is.\n */\nexport async function compactConversation(\n  ctx: PluginContext,\n  conversationId: string,\n  configOverride?: { preserveRecent?: number; prompt?: string; model?: string },\n): Promise<CompactionResult | null> {\n  const config = ctx.config.compaction;\n  const preserveRecent = configOverride?.preserveRecent ?? config?.preserveRecent ?? DEFAULTS.COMPACTION_PRESERVE_RECENT;\n  const prompt = configOverride?.prompt ?? config?.prompt ?? DEFAULT_COMPACTION_PROMPT;\n  const model = configOverride?.model ?? config?.model;\n\n  const conversation = await ctx.storage.conversations.get(conversationId);\n  if (!conversation) return null;\n\n  const messages = conversation.messages;\n  if (messages.length <= preserveRecent) {\n    return { summary: \"\", summarizedCount: 0, preservedCount: messages.length, newMessageCount: messages.length };\n  }\n\n  const toSummarize = messages.slice(0, messages.length - preserveRecent);\n  const toPreserve = messages.slice(messages.length - preserveRecent);\n\n  const formatted = formatMessagesForSummary(toSummarize);\n  const fullPrompt = `${prompt}\\n\\n---\\n\\n${formatted}`;\n\n  emitStatus({ code: STATUS_CODES.COMPACTING, message: \"Compacting conversation history\", metadata: { conversationId, summarizedCount: toSummarize.length, preservedCount: toPreserve.length } });\n\n  const result = await withResilience({\n    fn: (overrideModel) =>\n      generateText({\n        model: ctx.getModel(overrideModel ?? model),\n        prompt: fullPrompt,\n      }),\n    ctx,\n    modelId: model,\n  });\n\n  const summary = result.text;\n\n  // Clear and rebuild conversation with summary + preserved messages\n  await ctx.storage.conversations.clear(conversationId);\n\n  // Write the summary as a compaction message\n  await ctx.storage.conversations.append(conversationId, {\n    role: \"assistant\",\n    content: summary,\n    timestamp: new Date().toISOString(),\n    metadata: { [COMPACTION_METADATA_KEY]: true, summarizedCount: toSummarize.length },\n  });\n\n  // Write preserved messages back\n  for (const msg of toPreserve) {\n    await ctx.storage.conversations.append(conversationId, msg);\n  }\n\n  return {\n    summary,\n    summarizedCount: toSummarize.length,\n    preservedCount: toPreserve.length,\n    newMessageCount: 1 + toPreserve.length,\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/delegation-context.ts",
      "content": "import { AsyncLocalStorage } from \"node:async_hooks\";\nimport type { AgentEventBus } from \"../events/agent-events.js\";\nimport type { AgentRegistry } from \"../types.js\";\n\nexport interface DelegationContext {\n  /** Ordered list of agent names in the current call chain */\n  chain: string[];\n  /** Current nesting depth (0 = top-level call) */\n  depth: number;\n  /** Shared event bus for the entire call tree */\n  events?: AgentEventBus;\n  /** Signal to abort all AI SDK calls in this request tree */\n  abortSignal?: AbortSignal;\n  /** Name of the orchestrator that initiated this request tree */\n  orchestrator?: string;\n}\n\n/** Returns the set of orchestrator agent names (derived from registry at call time) */\nexport function getOrchestratorAgents(registry: AgentRegistry): Set<string> {\n  return registry.getOrchestratorNames();\n}\n\n/** AsyncLocalStorage instance that propagates delegation context through async boundaries */\nexport const delegationStore = new AsyncLocalStorage<DelegationContext>();\n\n/** Returns the event bus from the current delegation context, if any */\nexport function getEventBus(): AgentEventBus | undefined {\n  return delegationStore.getStore()?.events;\n}\n\n/** Returns the abort signal from the current delegation context, if any */\nexport function getAbortSignal(): AbortSignal | undefined {\n  return delegationStore.getStore()?.abortSignal;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/request-registry.ts",
      "content": "/** Registry of active streaming requests, keyed by conversationId.\n *  Used to abort in-flight AI SDK calls when the client cancels. */\n\nconst activeRequests = new Map<string, AbortController>();\n\n/** Register a new request and return its AbortController. */\nexport function registerRequest(conversationId: string): AbortController {\n  cancelRequest(conversationId);\n  const controller = new AbortController();\n  activeRequests.set(conversationId, controller);\n  return controller;\n}\n\n/** Abort an active request. Returns true if one was found and aborted. */\nexport function cancelRequest(conversationId: string): boolean {\n  const controller = activeRequests.get(conversationId);\n  if (!controller) return false;\n  controller.abort();\n  activeRequests.delete(conversationId);\n  return true;\n}\n\n/** Clean up after a request completes normally. */\nexport function unregisterRequest(conversationId: string): void {\n  activeRequests.delete(conversationId);\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/tool-examples.ts",
      "content": "/**\n * Structured tool use examples and description builder.\n *\n * Based on Anthropic research showing 72% -> 90% accuracy improvement\n * when tool descriptions include concrete examples.\n */\n\nexport interface ToolExample {\n  /** Optional name for the example (e.g. \"Minimal parameters\") */\n  name?: string;\n  /** The example input object */\n  input: Record<string, unknown>;\n  /** Optional description of why this example matters */\n  description?: string;\n}\n\n/**\n * Formats an array of ToolExamples into an XML-style `<examples>` block\n * suitable for appending to a tool description.\n */\nexport function formatExamplesBlock(examples: ToolExample[]): string {\n  if (examples.length === 0) return \"\";\n\n  const parts = examples.map((ex) => {\n    const nameAttr = ex.name ? ` name=\"${ex.name}\"` : \"\";\n    const lines = [`<example${nameAttr}>`, JSON.stringify(ex.input)];\n    if (ex.description) lines.push(ex.description);\n    lines.push(\"</example>\");\n    return lines.join(\"\\n\");\n  });\n\n  return `<examples>\\n${parts.join(\"\\n\")}\\n</examples>`;\n}\n\n/**\n * Builds a complete tool description by appending formatted examples\n * to the base description string. Returns the base description unchanged\n * if no examples are provided.\n */\nexport function buildToolDescription(description: string, examples?: ToolExample[]): string {\n  if (!examples || examples.length === 0) return description;\n  return `${description}\\n\\n${formatExamplesBlock(examples)}`;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/constants.ts",
      "content": "/** Well-known tool names used by the framework */\nexport const TOOL_NAMES = {\n  ROUTE_TO_AGENT: \"routeToAgent\",\n  CREATE_TASK: \"createTask\",\n  CLARIFY: \"clarify\",\n  MEMORY: \"memory\",\n} as const;\n\n/** Default configuration values */\nexport const DEFAULTS = {\n  MAX_DELEGATION_DEPTH: 3,\n  MAX_STEPS: 5,\n  SYNTHESIS_MESSAGE: \"Synthesizing results...\",\n  RESPONSE_SKILLS_KEY: \"_responseSkills\",\n  COMPACTION_THRESHOLD: 20,\n  COMPACTION_PRESERVE_RECENT: 4,\n  SUMMARY_LENGTH_LIMIT: 200,\n} as const;\n",
      "type": "kitn:package"
    },
    {
      "path": "core/utils/card-registry.ts",
      "content": "/** Data shape returned by card extractors */\nexport interface CardData {\n  type: string;\n  data: Record<string, unknown>;\n}\n\n/**\n * A function that inspects a tool result and optionally returns card data.\n * Return `null` if the extractor does not apply to this tool/result.\n */\nexport type CardExtractor = (toolName: string, result: unknown) => CardData | null;\n\n/**\n * Pluggable registry for extracting UI card data from tool results.\n *\n * Host applications register extractors that inspect tool results and produce\n * typed card data (e.g. weather cards, link previews). The orchestrator uses this\n * during streaming to collect cards without hardcoding tool-specific logic.\n *\n * @example\n * ```ts\n * const cards = new CardRegistry();\n * cards.register((toolName, result) => {\n *   if (toolName === \"getWeather\" && result?.location) {\n *     return { type: \"weather\", data: result };\n *   }\n *   return null;\n * });\n * ```\n */\nexport class CardRegistry {\n  private extractors: CardExtractor[] = [];\n\n  /** Register a card extractor. Returns an unsubscribe function. */\n  register(extractor: CardExtractor): () => void {\n    this.extractors.push(extractor);\n    return () => {\n      const idx = this.extractors.indexOf(extractor);\n      if (idx !== -1) this.extractors.splice(idx, 1);\n    };\n  }\n\n  /** Run all extractors against a tool result and return any produced cards. */\n  extract(toolName: string, result: unknown): CardData[] {\n    const cards: CardData[] = [];\n    for (const extractor of this.extractors) {\n      const card = extractor(toolName, result);\n      if (card) cards.push(card);\n    }\n    return cards;\n  }\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/schemas/agents.schemas.ts",
      "content": "import { z } from \"zod\";\nimport \"@asteasolutions/zod-to-openapi\";\n\nexport const agentRequestSchema = z.object({\n  message: z.string().min(1).openapi({ example: \"Hello, how can you help me?\" }),\n  conversationId: z.string().optional(),\n  model: z.string().optional().openapi({ example: \"openai/gpt-4o-mini\" }),\n  memoryIds: z.array(z.string()).optional().openapi({\n    example: [\"user-123\"],\n    description: \"Memory namespace IDs to load as context\",\n  }),\n  planMode: z.boolean().optional().openapi({\n    description: \"Force plan-only mode (orchestrator creates tasks but waits for approval before executing)\",\n  }),\n  approvedPlan: z.array(z.object({\n    agent: z.string(),\n    query: z.string(),\n    skills: z.array(z.string()).optional(),\n  })).optional().openapi({\n    description: \"Pre-approved task plan to execute immediately\",\n  }),\n  autonomous: z.boolean().optional().openapi({\n    description: \"Per-request override for autonomous mode (when false, orchestrator may ask user for input)\",\n  }),\n});\n\nexport const agentResponseSchema = z.object({\n  response: z.string(),\n  conversationId: z.string(),\n  toolsUsed: z.array(z.string()),\n});\n\nexport const approveRequestSchema = z.object({\n  id: z.string().min(1).openapi({ example: \"action_123_abc\" }),\n  approved: z.boolean().openapi({ example: true }),\n});\n\nexport const agentPatchSchema = z.object({\n  system: z.string().optional().openapi({\n    example: \"You are a helpful assistant.\",\n    description: \"New system prompt to use for this agent\",\n  }),\n  reset: z.boolean().optional().openapi({\n    example: true,\n    description: \"Reset system prompt to default\",\n  }),\n});\n",
      "type": "kitn:package"
    },
    {
      "path": "core/schemas/generate.schemas.ts",
      "content": "import { z } from \"zod\";\nimport \"@asteasolutions/zod-to-openapi\";\n\nexport const generateRequestSchema = z.object({\n  prompt: z.string().min(1).openapi({ example: \"Explain what an AI agent is\" }),\n  systemPrompt: z.string().optional().openapi({ example: \"You are a helpful assistant\" }),\n  model: z.string().optional().openapi({ example: \"openai/gpt-4o-mini\" }),\n  tools: z.array(z.string()).optional().openapi({ example: [\"myTool\"] }),\n  maxSteps: z.number().min(1).max(10).default(5),\n});\n\nexport const generateResponseSchema = z.object({\n  text: z.string(),\n  model: z.string(),\n  usage: z.object({\n    inputTokens: z.number().openapi({ example: 25 }),\n    outputTokens: z.number().openapi({ example: 150 }),\n    totalTokens: z.number().openapi({ example: 175 }),\n  }),\n  toolResults: z.array(z.any()).optional(),\n  finishReason: z.string(),\n});\n",
      "type": "kitn:package"
    },
    {
      "path": "core/schemas/voice.schemas.ts",
      "content": "import { z } from \"zod\";\nimport \"@asteasolutions/zod-to-openapi\";\n\nexport const speakRequestSchema = z.object({\n  text: z.string().min(1).openapi({ example: \"Hello, how can I help you today?\" }),\n  speaker: z.string().optional().openapi({ example: \"alloy\" }),\n  format: z.enum([\"mp3\", \"opus\", \"wav\", \"aac\", \"flac\"]).optional().openapi({ example: \"mp3\" }),\n  speed: z.number().min(0.25).max(4.0).optional().openapi({ example: 1.0 }),\n  model: z.string().optional(),\n  save: z.boolean().optional().openapi({ description: \"When true, buffer and save the audio server-side, returning X-Audio-Id header\" }),\n});\n\nexport const transcribeResponseSchema = z.object({\n  text: z.string(),\n  language: z.string().optional(),\n  duration: z.number().optional(),\n});\n\nexport const speakersResponseSchema = z.object({\n  speakers: z.array(z.object({ voiceId: z.string(), name: z.string() })),\n  provider: z.string(),\n});\n\nexport const converseResponseHeadersSchema = z.object({\n  \"X-Transcription\": z.string(),\n  \"X-Response-Text\": z.string(),\n  \"X-Conversation-Id\": z.string().optional(),\n});\n",
      "type": "kitn:package"
    },
    {
      "path": "core/schemas/memory.schemas.ts",
      "content": "import { z } from \"zod\";\nimport \"@asteasolutions/zod-to-openapi\";\n\nexport const memoryEntrySchema = z.object({\n  key: z.string(),\n  value: z.string(),\n  context: z.string(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n});\n\nexport const memorySaveSchema = z.object({\n  key: z.string().min(1).openapi({ example: \"user_name\" }),\n  value: z.string().min(1).openapi({ example: \"John\" }),\n  context: z.string().optional().default(\"\").openapi({\n    example: \"user preferences\",\n    description: \"What this memory is for\",\n  }),\n});\n",
      "type": "kitn:package"
    },
    {
      "path": "core/schemas/skills.schemas.ts",
      "content": "import { z } from \"zod\";\nimport \"@asteasolutions/zod-to-openapi\";\n\nexport const skillMetaSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  tags: z.array(z.string()),\n  phase: z.enum([\"query\", \"response\", \"both\"]),\n});\n\nexport const skillSchema = skillMetaSchema.extend({\n  content: z.string(),\n  rawContent: z.string(),\n  updatedAt: z.string(),\n});\n\nexport const skillCreateSchema = z.object({\n  name: z.string().min(1).regex(/^[a-z0-9]+(-[a-z0-9]+)*$/, \"Must be kebab-case\").openapi({ example: \"my-skill\" }),\n  content: z.string().min(1).openapi({\n    example: \"---\\nname: my-skill\\ndescription: Use when ...\\ntags: [tag1]\\nphase: response\\n---\\n# My Skill\\n\\n## Instructions\\n...\",\n    description: \"Full markdown content including frontmatter\",\n  }),\n});\n\nexport const skillUpdateSchema = z.object({\n  content: z.string().min(1).openapi({\n    example: \"---\\nname: my-skill\\ndescription: Use when ...\\ntags: [tag1]\\nphase: response\\n---\\n# My Skill\\n\\n## Instructions\\n...\",\n    description: \"Full markdown content including frontmatter\",\n  }),\n});\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/conversation-store.ts",
      "content": "import { readFile, writeFile, mkdir, readdir, unlink } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport type { ConversationStore, Conversation, ConversationMessage, ConversationSummary } from \"../interfaces.js\";\n\nexport function createConversationStore(dataDir: string): ConversationStore {\n  const dir = `${dataDir}/conversations`;\n\n  let lock: Promise<void> = Promise.resolve();\n  function withLock<T>(fn: () => Promise<T>): Promise<T> {\n    const prev = lock;\n    let result: Promise<T>;\n    const next = prev\n      .then(async () => { result = fn(); await result; })\n      .catch(() => {});\n    lock = next;\n    return next.then(() => result!);\n  }\n\n  function filePath(id: string): string { return `${dir}/${id}.json`; }\n\n  async function ensureDir() {\n    if (!existsSync(dir)) await mkdir(dir, { recursive: true });\n  }\n\n  async function readConversation(id: string): Promise<Conversation | null> {\n    const path = filePath(id);\n    if (!existsSync(path)) return null;\n    const raw = await readFile(path, \"utf-8\");\n    try { return JSON.parse(raw); } catch { return null; }\n  }\n\n  async function writeConversation(conv: Conversation): Promise<void> {\n    await ensureDir();\n    await writeFile(filePath(conv.id), JSON.stringify(conv, null, 2));\n  }\n\n  return {\n    async get(id) {\n      await ensureDir();\n      return readConversation(id);\n    },\n\n    async list() {\n      await ensureDir();\n      if (!existsSync(dir)) return [];\n      const files = await readdir(dir);\n      const summaries: ConversationSummary[] = [];\n      for (const file of files) {\n        if (!file.endsWith(\".json\")) continue;\n        const id = file.replace(\".json\", \"\");\n        const conv = await readConversation(id);\n        if (conv) {\n          summaries.push({ id: conv.id, messageCount: conv.messages.length, updatedAt: conv.updatedAt });\n        }\n      }\n      return summaries;\n    },\n\n    create(id) {\n      return withLock(async () => {\n        await ensureDir();\n        const now = new Date().toISOString();\n        const conv: Conversation = { id, messages: [], createdAt: now, updatedAt: now };\n        await writeConversation(conv);\n        return conv;\n      });\n    },\n\n    append(id, message) {\n      return withLock(async () => {\n        await ensureDir();\n        let conv = await readConversation(id);\n        if (!conv) {\n          const now = new Date().toISOString();\n          conv = { id, messages: [], createdAt: now, updatedAt: now };\n        }\n        conv.messages.push(message);\n        conv.updatedAt = new Date().toISOString();\n        await writeConversation(conv);\n        return conv;\n      });\n    },\n\n    async delete(id) {\n      const path = filePath(id);\n      if (!existsSync(path)) return false;\n      await unlink(path);\n      return true;\n    },\n\n    clear(id) {\n      return withLock(async () => {\n        let conv = await readConversation(id);\n        if (!conv) throw new Error(`Conversation not found: ${id}`);\n        conv.messages = [];\n        conv.updatedAt = new Date().toISOString();\n        await writeConversation(conv);\n        return conv;\n      });\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/memory-store.ts",
      "content": "import { readFile, writeFile, mkdir, readdir, unlink } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport type { MemoryStore, MemoryEntry } from \"../interfaces.js\";\n\ntype NamespaceData = Record<string, MemoryEntry>;\n\nexport function createMemoryStore(dataDir: string): MemoryStore {\n  const dir = join(dataDir, \"memory\");\n\n  const locks = new Map<string, Promise<void>>();\n  function withLock<T>(namespace: string, fn: () => Promise<T>): Promise<T> {\n    const prev = locks.get(namespace) ?? Promise.resolve();\n    let result: Promise<T>;\n    const next = prev\n      .then(async () => { result = fn(); await result; })\n      .catch(() => {});\n    locks.set(namespace, next);\n    return next.then(() => result!);\n  }\n\n  function namespacePath(namespaceId: string): string { return join(dir, `${namespaceId}.json`); }\n\n  async function ensureDir() {\n    if (!existsSync(dir)) await mkdir(dir, { recursive: true });\n  }\n\n  async function readNamespace(namespaceId: string): Promise<NamespaceData> {\n    await ensureDir();\n    const path = namespacePath(namespaceId);\n    if (!existsSync(path)) return {};\n    const raw = await readFile(path, \"utf-8\");\n    try { return JSON.parse(raw); } catch { return {}; }\n  }\n\n  async function writeNamespace(namespaceId: string, data: NamespaceData): Promise<void> {\n    await ensureDir();\n    await writeFile(namespacePath(namespaceId), JSON.stringify(data, null, 2));\n  }\n\n  return {\n    async listNamespaces() {\n      await ensureDir();\n      const files = await readdir(dir);\n      return files.filter((f) => f.endsWith(\".json\")).map((f) => f.replace(\".json\", \"\"));\n    },\n\n    async listEntries(namespaceId) {\n      const data = await readNamespace(namespaceId);\n      return Object.values(data);\n    },\n\n    saveEntry(namespaceId, key, value, context = \"\") {\n      return withLock(namespaceId, async () => {\n        const data = await readNamespace(namespaceId);\n        const now = new Date().toISOString();\n        const entry: MemoryEntry = {\n          key, value, context,\n          createdAt: data[key]?.createdAt ?? now,\n          updatedAt: now,\n        };\n        data[key] = entry;\n        await writeNamespace(namespaceId, data);\n        return entry;\n      });\n    },\n\n    async getEntry(namespaceId, key) {\n      const data = await readNamespace(namespaceId);\n      return data[key] ?? null;\n    },\n\n    deleteEntry(namespaceId, key) {\n      return withLock(namespaceId, async () => {\n        const data = await readNamespace(namespaceId);\n        if (!data[key]) return false;\n        delete data[key];\n        await writeNamespace(namespaceId, data);\n        return true;\n      });\n    },\n\n    clearNamespace(namespaceId) {\n      return withLock(namespaceId, async () => {\n        const path = namespacePath(namespaceId);\n        if (existsSync(path)) await unlink(path);\n      });\n    },\n\n    async loadMemoriesForIds(ids) {\n      const results: Array<MemoryEntry & { namespace: string }> = [];\n      await Promise.all(\n        ids.map(async (id) => {\n          const data = await readNamespace(id);\n          for (const entry of Object.values(data)) {\n            results.push({ ...entry, namespace: id });\n          }\n        }),\n      );\n      return results;\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/task-store.ts",
      "content": "import { readFile, writeFile, mkdir } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport type { TaskStore, Task } from \"../interfaces.js\";\n\nexport function createTaskStore(dataDir: string): TaskStore {\n  const tasksFile = `${dataDir}/tasks.json`;\n\n  let lock: Promise<void> = Promise.resolve();\n  function withLock<T>(fn: () => Promise<T>): Promise<T> {\n    const prev = lock;\n    let result: Promise<T>;\n    const next = prev\n      .then(async () => { result = fn(); await result; })\n      .catch(() => {});\n    lock = next;\n    return next.then(() => result!);\n  }\n\n  async function ensureDir() {\n    if (!existsSync(dataDir)) await mkdir(dataDir, { recursive: true });\n  }\n\n  async function readTasks(): Promise<Task[]> {\n    await ensureDir();\n    if (!existsSync(tasksFile)) return [];\n    const raw = await readFile(tasksFile, \"utf-8\");\n    try { return JSON.parse(raw); } catch { return []; }\n  }\n\n  async function writeTasks(data: Task[]): Promise<void> {\n    await ensureDir();\n    await writeFile(tasksFile, JSON.stringify(data, null, 2));\n  }\n\n  function generateId(): string { return Date.now().toString(36); }\n\n  return {\n    createTask(title) {\n      return withLock(async () => {\n        const tasks = await readTasks();\n        const now = new Date().toISOString();\n        const task: Task = { id: generateId(), title, status: \"todo\", createdAt: now, updatedAt: now };\n        tasks.push(task);\n        await writeTasks(tasks);\n        return task;\n      });\n    },\n\n    async listTasks() { return readTasks(); },\n\n    updateTask(id, updates) {\n      return withLock(async () => {\n        const tasks = await readTasks();\n        const task = tasks.find((t) => t.id === id);\n        if (!task) throw new Error(`Task not found: ${id}`);\n        if (updates.title !== undefined) task.title = updates.title;\n        if (updates.status !== undefined) task.status = updates.status;\n        task.updatedAt = new Date().toISOString();\n        await writeTasks(tasks);\n        return task;\n      });\n    },\n\n    deleteTask(id) {\n      return withLock(async () => {\n        const tasks = await readTasks();\n        const index = tasks.findIndex((t) => t.id === id);\n        if (index === -1) return false;\n        tasks.splice(index, 1);\n        await writeTasks(tasks);\n        return true;\n      });\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/prompt-store.ts",
      "content": "import { readFile, writeFile, mkdir } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { dirname } from \"node:path\";\nimport type { PromptStore, PromptOverride } from \"../interfaces.js\";\n\nexport function createPromptStore(dataDir: string): PromptStore {\n  const overridesFile = `${dataDir}/prompt-overrides.json`;\n\n  let lock: Promise<void> = Promise.resolve();\n  function withLock<T>(fn: () => Promise<T>): Promise<T> {\n    let result: Promise<T>;\n    lock = lock\n      .then(async () => { result = fn(); await result; })\n      .catch(() => {});\n    return lock.then(() => result!);\n  }\n\n  async function ensureFile() {\n    const dir = dirname(overridesFile);\n    if (!existsSync(dir)) await mkdir(dir, { recursive: true });\n    if (!existsSync(overridesFile)) await writeFile(overridesFile, JSON.stringify({}, null, 2));\n  }\n\n  return {\n    async loadOverrides() {\n      await ensureFile();\n      const raw = await readFile(overridesFile, \"utf-8\");\n      try { return JSON.parse(raw); } catch { return {}; }\n    },\n\n    saveOverride(name, prompt) {\n      return withLock(async () => {\n        await ensureFile();\n        const raw = await readFile(overridesFile, \"utf-8\");\n        const parsed: unknown = JSON.parse(raw);\n        const data: Record<string, PromptOverride> = parsed !== null && typeof parsed === \"object\" && !Array.isArray(parsed)\n          ? parsed as Record<string, PromptOverride>\n          : {};\n        const entry: PromptOverride = { prompt, updatedAt: new Date().toISOString() };\n        data[name] = entry;\n        await writeFile(overridesFile, JSON.stringify(data, null, 2));\n        return entry;\n      });\n    },\n\n    deleteOverride(name) {\n      return withLock(async () => {\n        await ensureFile();\n        const raw = await readFile(overridesFile, \"utf-8\");\n        const parsed: unknown = JSON.parse(raw);\n        const data: Record<string, PromptOverride> = parsed !== null && typeof parsed === \"object\" && !Array.isArray(parsed)\n          ? parsed as Record<string, PromptOverride>\n          : {};\n        if (!data[name]) return false;\n        delete data[name];\n        await writeFile(overridesFile, JSON.stringify(data, null, 2));\n        return true;\n      });\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/audio-store.ts",
      "content": "import { readFile, writeFile, mkdir, readdir, unlink } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport type { AudioStore, AudioEntry } from \"../interfaces.js\";\n\nconst META_SUFFIX = \".meta.json\";\n\nfunction generateId(): string {\n  const ts = Date.now().toString(36);\n  const rand = Math.random().toString(36).slice(2, 8);\n  return `${ts}-${rand}`;\n}\n\nfunction extension(mimeType: string): string {\n  const map: Record<string, string> = {\n    \"audio/mpeg\": \"mp3\", \"audio/mp3\": \"mp3\", \"audio/webm\": \"webm\",\n    \"video/webm\": \"webm\", \"audio/wav\": \"wav\", \"audio/ogg\": \"ogg\",\n    \"audio/opus\": \"opus\", \"audio/aac\": \"aac\", \"audio/flac\": \"flac\",\n  };\n  return map[mimeType] ?? \"bin\";\n}\n\nexport function createAudioStore(dataDir: string): AudioStore {\n  const dir = join(dataDir, \"audio\");\n\n  async function ensureDir() {\n    if (!existsSync(dir)) await mkdir(dir, { recursive: true });\n  }\n\n  return {\n    async saveAudio(buffer, mimeType, metadata?) {\n      await ensureDir();\n      const id = generateId();\n      const ext = extension(mimeType);\n      const audioPath = join(dir, `${id}.${ext}`);\n      const metaPath = join(dir, `${id}${META_SUFFIX}`);\n      const entry: AudioEntry = { id, mimeType, size: buffer.length, createdAt: new Date().toISOString(), metadata };\n      await Promise.all([writeFile(audioPath, buffer), writeFile(metaPath, JSON.stringify(entry, null, 2))]);\n      return entry;\n    },\n\n    async getAudio(id) {\n      await ensureDir();\n      const files = await readdir(dir);\n      const metaFile = files.find((f) => f.startsWith(id) && f.endsWith(META_SUFFIX));\n      if (!metaFile) return null;\n      const metaPath = join(dir, metaFile);\n      const raw = await readFile(metaPath, \"utf-8\");\n      const entry: AudioEntry = JSON.parse(raw);\n      const audioFile = files.find((f) => f.startsWith(id) && !f.endsWith(META_SUFFIX));\n      if (!audioFile) return null;\n      const data = await readFile(join(dir, audioFile));\n      return { entry, data };\n    },\n\n    async deleteAudio(id) {\n      await ensureDir();\n      const files = await readdir(dir);\n      const matching = files.filter((f) => f.startsWith(id));\n      if (matching.length === 0) return false;\n      await Promise.all(matching.map((f) => unlink(join(dir, f))));\n      return true;\n    },\n\n    async listAudio() {\n      await ensureDir();\n      const files = await readdir(dir);\n      const metaFiles = files.filter((f) => f.endsWith(META_SUFFIX));\n      const entries: AudioEntry[] = [];\n      for (const metaFile of metaFiles) {\n        try {\n          const raw = await readFile(join(dir, metaFile), \"utf-8\");\n          entries.push(JSON.parse(raw));\n        } catch { /* skip corrupted */ }\n      }\n      return entries.sort((a, b) => b.createdAt.localeCompare(a.createdAt));\n    },\n\n    async cleanupOlderThan(maxAgeMs) {\n      await ensureDir();\n      const cutoff = Date.now() - maxAgeMs;\n      const entries = await this.listAudio();\n      let deleted = 0;\n      for (const entry of entries) {\n        if (new Date(entry.createdAt).getTime() < cutoff) {\n          await this.deleteAudio(entry.id);\n          deleted++;\n        }\n      }\n      return deleted;\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/index.ts",
      "content": "import { resolve } from \"node:path\";\nimport type { StorageProvider } from \"../interfaces.js\";\nimport { createConversationStore } from \"./conversation-store.js\";\nimport { createMemoryStore } from \"./memory-store.js\";\nimport { createSkillStore } from \"./skill-store.js\";\nimport { createTaskStore } from \"./task-store.js\";\nimport { createPromptStore } from \"./prompt-store.js\";\nimport { createAudioStore } from \"./audio-store.js\";\n\nexport interface FileStorageOptions {\n  /** Base directory for all data files (e.g. \"./data\") */\n  dataDir: string;\n}\n\nexport function createFileStorage(options: FileStorageOptions): StorageProvider {\n  const dataDir = resolve(options.dataDir);\n\n  return {\n    conversations: createConversationStore(dataDir),\n    memory: createMemoryStore(dataDir),\n    skills: createSkillStore(dataDir),\n    tasks: createTaskStore(dataDir),\n    prompts: createPromptStore(dataDir),\n    audio: createAudioStore(dataDir),\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/file-storage/skill-store.ts",
      "content": "import { readFile, writeFile, mkdir, readdir, rm } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport type { SkillStore, SkillMeta } from \"../interfaces.js\";\nimport { parseFrontmatter, parsePhase, buildSkill, KEBAB_CASE } from \"../skill-helpers.js\";\n\n// Re-export for any external consumers that imported from here\nexport { parseFrontmatter } from \"../skill-helpers.js\";\n\nexport function createSkillStore(dataDir: string): SkillStore {\n  const dir = join(dataDir, \"skills\");\n\n  const locks = new Map<string, Promise<void>>();\n  function withLock<T>(name: string, fn: () => Promise<T>): Promise<T> {\n    const prev = locks.get(name) ?? Promise.resolve();\n    let result: Promise<T>;\n    const next = prev\n      .then(async () => { result = fn(); await result; })\n      .catch(() => {});\n    locks.set(name, next);\n    return next.then(() => result!);\n  }\n\n  function skillDir(name: string): string { return join(dir, name); }\n  function readmePath(name: string): string { return join(dir, name, \"README.md\"); }\n\n  async function ensureDir() {\n    if (!existsSync(dir)) await mkdir(dir, { recursive: true });\n  }\n\n  return {\n    async listSkills() {\n      await ensureDir();\n      const entries = await readdir(dir, { withFileTypes: true });\n      const skills: SkillMeta[] = [];\n      for (const entry of entries) {\n        if (!entry.isDirectory()) continue;\n        const readme = readmePath(entry.name);\n        if (!existsSync(readme)) continue;\n        const raw = await readFile(readme, \"utf-8\");\n        const { meta } = parseFrontmatter(raw);\n        skills.push({\n          name: (meta.name as string) || entry.name,\n          description: (meta.description as string) || \"\",\n          tags: Array.isArray(meta.tags) ? meta.tags : [],\n          phase: parsePhase(meta.phase),\n        });\n      }\n      return skills;\n    },\n\n    async getSkill(name) {\n      await ensureDir();\n      const path = readmePath(name);\n      if (!existsSync(path)) return null;\n      const raw = await readFile(path, \"utf-8\");\n      return buildSkill(name, raw);\n    },\n\n    createSkill(name, content) {\n      if (!KEBAB_CASE.test(name)) {\n        throw new Error(`Invalid skill name \"${name}\": must be kebab-case (e.g. \"my-skill\")`);\n      }\n      return withLock(name, async () => {\n        await ensureDir();\n        const d = skillDir(name);\n        if (existsSync(d)) throw new Error(`Skill \"${name}\" already exists`);\n        await mkdir(d, { recursive: true });\n        await writeFile(readmePath(name), content, \"utf-8\");\n        return buildSkill(name, content);\n      });\n    },\n\n    updateSkill(name, content) {\n      return withLock(name, async () => {\n        await ensureDir();\n        const path = readmePath(name);\n        if (!existsSync(path)) throw new Error(`Skill \"${name}\" not found`);\n        await writeFile(path, content, \"utf-8\");\n        return buildSkill(name, content);\n      });\n    },\n\n    deleteSkill(name) {\n      return withLock(name, async () => {\n        await ensureDir();\n        const d = skillDir(name);\n        if (!existsSync(d)) return false;\n        await rm(d, { recursive: true });\n        return true;\n      });\n    },\n\n    async getSkillSummaries() {\n      const skills = await this.listSkills();\n      if (skills.length === 0) return \"No skills available.\";\n      return skills.map((s) => `- ${s.name} [${s.phase}]: ${s.description}`).join(\"\\n\");\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/skill-helpers.ts",
      "content": "import type { Skill, SkillPhase } from \"./interfaces.js\";\n\nconst VALID_PHASES = new Set<SkillPhase>([\"query\", \"response\", \"both\"]);\n\nexport const KEBAB_CASE = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n\n/** Simple frontmatter parser — handles `key: value` and `key: [a, b]` */\nexport function parseFrontmatter(raw: string): {\n  meta: Record<string, string | string[]>;\n  body: string;\n} {\n  const match = raw.match(/^---\\n([\\s\\S]*?)\\n---\\n?([\\s\\S]*)$/);\n  if (!match) return { meta: {}, body: raw };\n\n  const meta: Record<string, string | string[]> = {};\n  for (const line of match[1].split(\"\\n\")) {\n    const idx = line.indexOf(\":\");\n    if (idx === -1) continue;\n    const key = line.slice(0, idx).trim();\n    const value = line.slice(idx + 1).trim();\n    const arrMatch = value.match(/^\\[(.*)\\]$/);\n    if (arrMatch) {\n      meta[key] = arrMatch[1].split(\",\").map((s) => s.trim()).filter(Boolean);\n    } else {\n      meta[key] = value;\n    }\n  }\n\n  return { meta, body: match[2] };\n}\n\nexport function parsePhase(value: unknown): SkillPhase {\n  if (typeof value === \"string\" && VALID_PHASES.has(value as SkillPhase)) {\n    return value as SkillPhase;\n  }\n  return \"response\";\n}\n\nexport function buildSkill(name: string, raw: string): Skill {\n  const { meta, body } = parseFrontmatter(raw);\n  return {\n    name: (meta.name as string) || name,\n    description: (meta.description as string) || \"\",\n    tags: Array.isArray(meta.tags) ? meta.tags : [],\n    phase: parsePhase(meta.phase),\n    content: body.trim(),\n    rawContent: raw,\n    updatedAt: new Date().toISOString(),\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/interfaces.ts",
      "content": "// ── Conversation Store ──\n\n/** A single message within a conversation */\nexport interface ConversationMessage {\n  role: \"user\" | \"assistant\";\n  content: string;\n  timestamp: string;\n  /** Optional metadata (e.g. cards, tool results) attached to this message */\n  metadata?: Record<string, unknown>;\n}\n\n/** Full conversation record including all messages */\nexport interface Conversation {\n  id: string;\n  messages: ConversationMessage[];\n  createdAt: string;\n  updatedAt: string;\n}\n\n/** Lightweight conversation summary for listing */\nexport interface ConversationSummary {\n  id: string;\n  messageCount: number;\n  updatedAt: string;\n}\n\n/**\n * Stores and retrieves multi-turn conversations.\n *\n * Implementations should auto-create conversations on first `append()` if they don't exist.\n * Return `null` from `get()` when a conversation is not found (do not throw).\n *\n * @example\n * ```ts\n * class PostgresConversationStore implements ConversationStore {\n *   async get(id: string) {\n *     const row = await db.query(\"SELECT * FROM conversations WHERE id = $1\", [id]);\n *     return row ? deserialize(row) : null;\n *   }\n *   async append(id: string, message: ConversationMessage) {\n *     // Upsert conversation, then append message\n *   }\n *   // ...\n * }\n * ```\n */\nexport interface ConversationStore {\n  /** Get a conversation by ID. Returns `null` if not found. */\n  get(id: string): Promise<Conversation | null>;\n  /** List all conversations as lightweight summaries. */\n  list(): Promise<ConversationSummary[]>;\n  /** Create a new empty conversation with the given ID. */\n  create(id: string): Promise<Conversation>;\n  /** Append a message to a conversation, creating it if necessary. */\n  append(id: string, message: ConversationMessage): Promise<Conversation>;\n  /** Delete a conversation by ID. Returns `true` if it existed. */\n  delete(id: string): Promise<boolean>;\n  /** Clear all messages from a conversation, keeping the record. */\n  clear(id: string): Promise<Conversation>;\n}\n\n// ── Memory Store ──\n\n/** A single key-value memory entry within a namespace */\nexport interface MemoryEntry {\n  key: string;\n  value: string;\n  context: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Namespaced key-value store for agent memory.\n *\n * Namespaces are created implicitly when the first entry is saved.\n * Return `null` from `getEntry()` when a key is not found (do not throw).\n * `loadMemoriesForIds()` aggregates entries across multiple namespaces for context injection.\n */\nexport interface MemoryStore {\n  /** List all namespace IDs that contain at least one entry. */\n  listNamespaces(): Promise<string[]>;\n  /** List all entries within a namespace. Returns empty array if namespace doesn't exist. */\n  listEntries(namespaceId: string): Promise<MemoryEntry[]>;\n  /** Create or update a memory entry. The namespace is created implicitly. */\n  saveEntry(namespaceId: string, key: string, value: string, context?: string): Promise<MemoryEntry>;\n  /** Get a single entry by namespace + key. Returns `null` if not found. */\n  getEntry(namespaceId: string, key: string): Promise<MemoryEntry | null>;\n  /** Delete a single entry. Returns `true` if it existed. */\n  deleteEntry(namespaceId: string, key: string): Promise<boolean>;\n  /** Remove all entries in a namespace. */\n  clearNamespace(namespaceId: string): Promise<void>;\n  /** Load entries from multiple namespaces at once, tagged with their namespace. */\n  loadMemoriesForIds(ids: string[]): Promise<Array<MemoryEntry & { namespace: string }>>;\n}\n\n// ── Skill Store ──\n\n/** Phase determines when a skill's instructions are injected */\nexport type SkillPhase = \"query\" | \"response\" | \"both\";\n\n/** Lightweight skill metadata for listing */\nexport interface SkillMeta {\n  name: string;\n  description: string;\n  tags: string[];\n  phase: SkillPhase;\n}\n\n/** Full skill record including parsed content */\nexport interface Skill extends SkillMeta {\n  /** Parsed content body (frontmatter removed) */\n  content: string;\n  /** Original raw content including frontmatter */\n  rawContent: string;\n  updatedAt: string;\n}\n\n/**\n * Stores behavioral skill definitions with YAML frontmatter.\n *\n * Skills are markdown documents with frontmatter containing `name`, `description`,\n * `tags`, and `phase`. The store is responsible for parsing frontmatter on create/update.\n * Return `null` from `getSkill()` when not found (do not throw).\n * `getSkillSummaries()` returns a formatted string suitable for injection into system prompts.\n */\nexport interface SkillStore {\n  /** List all skills as lightweight metadata. */\n  listSkills(): Promise<SkillMeta[]>;\n  /** Get a skill by name. Returns `null` if not found. */\n  getSkill(name: string): Promise<Skill | null>;\n  /** Create a new skill from raw markdown content (including frontmatter). */\n  createSkill(name: string, content: string): Promise<Skill>;\n  /** Update an existing skill's content. */\n  updateSkill(name: string, content: string): Promise<Skill>;\n  /** Delete a skill by name. Returns `true` if it existed. */\n  deleteSkill(name: string): Promise<boolean>;\n  /** Get a formatted summary of all skills, suitable for system prompt injection. */\n  getSkillSummaries(): Promise<string>;\n}\n\n// ── Task Store ──\n\n/** A simple task record for tracking work items */\nexport interface Task {\n  id: string;\n  title: string;\n  status: \"todo\" | \"in-progress\" | \"done\";\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Simple task/todo store for tracking work items.\n *\n * Tasks have three statuses: `todo`, `in-progress`, `done`.\n */\nexport interface TaskStore {\n  /** Create a new task with status `todo`. */\n  createTask(title: string): Promise<Task>;\n  /** List all tasks. */\n  listTasks(): Promise<Task[]>;\n  /** Update a task's title and/or status. */\n  updateTask(id: string, updates: { title?: string; status?: \"todo\" | \"in-progress\" | \"done\" }): Promise<Task>;\n  /** Delete a task by ID. Returns `true` if it existed. */\n  deleteTask(id: string): Promise<boolean>;\n}\n\n// ── Prompt Store ──\n\n/** A stored system prompt override for an agent */\nexport interface PromptOverride {\n  prompt: string;\n  updatedAt: string;\n}\n\n/**\n * Persists system prompt overrides for agents.\n *\n * When an agent's prompt is customized at runtime, it is saved here and\n * loaded during `plugin.initialize()` to restore overrides across restarts.\n */\nexport interface PromptStore {\n  /** Load all stored prompt overrides, keyed by agent name. */\n  loadOverrides(): Promise<Record<string, PromptOverride>>;\n  /** Save or update a prompt override for an agent. */\n  saveOverride(name: string, prompt: string): Promise<PromptOverride>;\n  /** Remove a prompt override. Returns `true` if it existed. */\n  deleteOverride(name: string): Promise<boolean>;\n}\n\n// ── Audio Store ──\n\n/** Metadata for a stored audio file */\nexport interface AudioEntry {\n  id: string;\n  mimeType: string;\n  size: number;\n  createdAt: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Stores and retrieves audio files for the voice subsystem.\n *\n * Audio entries are identified by auto-generated IDs. Return `null` from\n * `getAudio()` when not found (do not throw).\n * `cleanupOlderThan()` removes entries older than the given age for garbage collection.\n */\nexport interface AudioStore {\n  /** Save an audio buffer and return its entry metadata. */\n  saveAudio(buffer: Buffer | Uint8Array, mimeType: string, metadata?: Record<string, unknown>): Promise<AudioEntry>;\n  /** Retrieve an audio file by ID. Returns `null` if not found. */\n  getAudio(id: string): Promise<{ entry: AudioEntry; data: Buffer } | null>;\n  /** Delete an audio file by ID. Returns `true` if it existed. */\n  deleteAudio(id: string): Promise<boolean>;\n  /** List all stored audio entries. */\n  listAudio(): Promise<AudioEntry[]>;\n  /** Remove audio entries older than `maxAgeMs` milliseconds. Returns count of deleted entries. */\n  cleanupOlderThan(maxAgeMs: number): Promise<number>;\n}\n\n// ── Combined Storage Provider ──\n\n/**\n * Aggregates all sub-stores into a single provider.\n *\n * Pass an implementation of this interface to `createAIPlugin({ storage })`.\n * Use `createFileStorage()` for a ready-made file-based implementation,\n * or implement each sub-store to back onto your own database.\n *\n * @example\n * ```ts\n * const storage: StorageProvider = {\n *   conversations: new PostgresConversationStore(db),\n *   memory: new PostgresMemoryStore(db),\n *   skills: new PostgresSkillStore(db),\n *   tasks: new PostgresTaskStore(db),\n *   prompts: new PostgresPromptStore(db),\n *   audio: new S3AudioStore(bucket),\n * };\n * const plugin = createAIPlugin({ getModel, storage });\n * ```\n */\nexport interface StorageProvider {\n  conversations: ConversationStore;\n  memory: MemoryStore;\n  skills: SkillStore;\n  tasks: TaskStore;\n  prompts: PromptStore;\n  audio: AudioStore;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/in-memory/memory-store.ts",
      "content": "import type { MemoryStore, MemoryEntry } from \"../interfaces.js\";\n\n/**\n * Creates an in-memory (Map-based) implementation of MemoryStore.\n * All data lives in process memory and is lost on restart.\n * Useful as the default backing store for the built-in _memory tool.\n */\nexport function createInMemoryMemoryStore(): MemoryStore {\n  // namespace -> (key -> entry)\n  const store = new Map<string, Map<string, MemoryEntry>>();\n\n  function getNamespace(id: string): Map<string, MemoryEntry> {\n    let ns = store.get(id);\n    if (!ns) {\n      ns = new Map();\n      store.set(id, ns);\n    }\n    return ns;\n  }\n\n  return {\n    async listNamespaces() {\n      const namespaces: string[] = [];\n      for (const [id, entries] of store) {\n        if (entries.size > 0) namespaces.push(id);\n      }\n      return namespaces;\n    },\n\n    async listEntries(namespaceId: string) {\n      const ns = store.get(namespaceId);\n      return ns ? [...ns.values()] : [];\n    },\n\n    async saveEntry(namespaceId: string, key: string, value: string, context?: string) {\n      const ns = getNamespace(namespaceId);\n      const existing = ns.get(key);\n      const now = new Date().toISOString();\n      const entry: MemoryEntry = {\n        key,\n        value,\n        context: context ?? \"\",\n        createdAt: existing?.createdAt ?? now,\n        updatedAt: now,\n      };\n      ns.set(key, entry);\n      return entry;\n    },\n\n    async getEntry(namespaceId: string, key: string) {\n      return store.get(namespaceId)?.get(key) ?? null;\n    },\n\n    async deleteEntry(namespaceId: string, key: string) {\n      const ns = store.get(namespaceId);\n      if (!ns) return false;\n      return ns.delete(key);\n    },\n\n    async clearNamespace(namespaceId: string) {\n      store.delete(namespaceId);\n    },\n\n    async loadMemoriesForIds(ids: string[]) {\n      const results: Array<MemoryEntry & { namespace: string }> = [];\n      for (const id of ids) {\n        const ns = store.get(id);\n        if (!ns) continue;\n        for (const entry of ns.values()) {\n          results.push({ ...entry, namespace: id });\n        }\n      }\n      return results;\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/storage/in-memory/index.ts",
      "content": "import type {\n  StorageProvider,\n  ConversationStore,\n  Conversation,\n  ConversationSummary,\n  SkillStore,\n  SkillMeta,\n  TaskStore,\n  Task,\n  PromptStore,\n  PromptOverride,\n  AudioStore,\n  AudioEntry,\n} from \"../interfaces.js\";\nimport { createInMemoryMemoryStore } from \"./memory-store.js\";\nimport { parseFrontmatter, parsePhase, buildSkill, KEBAB_CASE } from \"../skill-helpers.js\";\n\n// ── Conversation Store ──\n\nfunction createConversationStore(): ConversationStore {\n  const store = new Map<string, Conversation>();\n\n  return {\n    async get(id) {\n      return store.get(id) ?? null;\n    },\n\n    async list() {\n      const summaries: ConversationSummary[] = [];\n      for (const conv of store.values()) {\n        summaries.push({\n          id: conv.id,\n          messageCount: conv.messages.length,\n          updatedAt: conv.updatedAt,\n        });\n      }\n      return summaries;\n    },\n\n    async create(id) {\n      const now = new Date().toISOString();\n      const conv: Conversation = { id, messages: [], createdAt: now, updatedAt: now };\n      store.set(id, conv);\n      return conv;\n    },\n\n    async append(id, message) {\n      let conv = store.get(id);\n      if (!conv) {\n        const now = new Date().toISOString();\n        conv = { id, messages: [], createdAt: now, updatedAt: now };\n        store.set(id, conv);\n      }\n      conv.messages.push(message);\n      conv.updatedAt = new Date().toISOString();\n      return conv;\n    },\n\n    async delete(id) {\n      return store.delete(id);\n    },\n\n    async clear(id) {\n      const conv = store.get(id);\n      if (!conv) {\n        const now = new Date().toISOString();\n        const fresh: Conversation = { id, messages: [], createdAt: now, updatedAt: now };\n        store.set(id, fresh);\n        return fresh;\n      }\n      conv.messages = [];\n      conv.updatedAt = new Date().toISOString();\n      return conv;\n    },\n  };\n}\n\n// ── Skill Store ──\n\nfunction createSkillStore(): SkillStore {\n  const store = new Map<string, string>(); // name -> raw content\n\n  return {\n    async listSkills() {\n      const skills: SkillMeta[] = [];\n      for (const [name, raw] of store) {\n        const { meta } = parseFrontmatter(raw);\n        skills.push({\n          name: (meta.name as string) || name,\n          description: (meta.description as string) || \"\",\n          tags: Array.isArray(meta.tags) ? meta.tags : [],\n          phase: parsePhase(meta.phase),\n        });\n      }\n      return skills;\n    },\n\n    async getSkill(name) {\n      const raw = store.get(name);\n      if (!raw) return null;\n      return buildSkill(name, raw);\n    },\n\n    async createSkill(name, content) {\n      if (!KEBAB_CASE.test(name)) {\n        throw new Error(`Invalid skill name \"${name}\": must be kebab-case (e.g. \"my-skill\")`);\n      }\n      if (store.has(name)) throw new Error(`Skill \"${name}\" already exists`);\n      store.set(name, content);\n      return buildSkill(name, content);\n    },\n\n    async updateSkill(name, content) {\n      if (!store.has(name)) throw new Error(`Skill \"${name}\" not found`);\n      store.set(name, content);\n      return buildSkill(name, content);\n    },\n\n    async deleteSkill(name) {\n      return store.delete(name);\n    },\n\n    async getSkillSummaries() {\n      const skills = await this.listSkills();\n      if (skills.length === 0) return \"No skills available.\";\n      return skills.map((s) => `- ${s.name} [${s.phase}]: ${s.description}`).join(\"\\n\");\n    },\n  };\n}\n\n// ── Task Store ──\n\nfunction createTaskStore(): TaskStore {\n  const store = new Map<string, Task>();\n  let nextId = 1;\n\n  return {\n    async createTask(title) {\n      const now = new Date().toISOString();\n      const task: Task = { id: String(nextId++), title, status: \"todo\", createdAt: now, updatedAt: now };\n      store.set(task.id, task);\n      return task;\n    },\n\n    async listTasks() {\n      return [...store.values()];\n    },\n\n    async updateTask(id, updates) {\n      const task = store.get(id);\n      if (!task) throw new Error(`Task \"${id}\" not found`);\n      if (updates.title !== undefined) task.title = updates.title;\n      if (updates.status !== undefined) task.status = updates.status;\n      task.updatedAt = new Date().toISOString();\n      return task;\n    },\n\n    async deleteTask(id) {\n      return store.delete(id);\n    },\n  };\n}\n\n// ── Prompt Store ──\n\nfunction createPromptStore(): PromptStore {\n  const store = new Map<string, PromptOverride>();\n\n  return {\n    async loadOverrides() {\n      const result: Record<string, PromptOverride> = {};\n      for (const [name, override] of store) {\n        result[name] = override;\n      }\n      return result;\n    },\n\n    async saveOverride(name, prompt) {\n      const override: PromptOverride = { prompt, updatedAt: new Date().toISOString() };\n      store.set(name, override);\n      return override;\n    },\n\n    async deleteOverride(name) {\n      return store.delete(name);\n    },\n  };\n}\n\n// ── Audio Store ──\n\nfunction createAudioStore(): AudioStore {\n  const entries = new Map<string, { entry: AudioEntry; data: Buffer }>();\n  let nextId = 1;\n\n  return {\n    async saveAudio(buffer, mimeType, metadata) {\n      const id = `audio_${nextId++}_${Date.now()}`;\n      const entry: AudioEntry = {\n        id,\n        mimeType,\n        size: buffer.length,\n        createdAt: new Date().toISOString(),\n        ...(metadata && { metadata }),\n      };\n      entries.set(id, { entry, data: Buffer.from(buffer) });\n      return entry;\n    },\n\n    async getAudio(id) {\n      return entries.get(id) ?? null;\n    },\n\n    async deleteAudio(id) {\n      return entries.delete(id);\n    },\n\n    async listAudio() {\n      return [...entries.values()].map((e) => e.entry);\n    },\n\n    async cleanupOlderThan(maxAgeMs) {\n      const cutoff = Date.now() - maxAgeMs;\n      let deleted = 0;\n      for (const [id, { entry }] of entries) {\n        if (new Date(entry.createdAt).getTime() < cutoff) {\n          entries.delete(id);\n          deleted++;\n        }\n      }\n      return deleted;\n    },\n  };\n}\n\n// ── Combined Provider ──\n\n/**\n * Creates a fully in-memory StorageProvider.\n * All data lives in process memory and is lost on restart.\n * Ideal for testing, development, and demos where disk persistence isn't needed.\n */\nexport function createMemoryStorage(): StorageProvider {\n  return {\n    conversations: createConversationStore(),\n    memory: createInMemoryMemoryStore(),\n    skills: createSkillStore(),\n    tasks: createTaskStore(),\n    prompts: createPromptStore(),\n    audio: createAudioStore(),\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/streaming/stream-helpers.ts",
      "content": "import { streamText, stepCountIs } from \"ai\";\nimport { createSSEStream } from \"./sse-writer.js\";\nimport { extractStreamUsage } from \"../utils/ai-provider.js\";\nimport { getEventBus, getAbortSignal } from \"../utils/delegation-context.js\";\nimport { registerRequest, unregisterRequest } from \"../utils/request-registry.js\";\nimport { SSE_EVENTS, BUS_EVENTS, STATUS_CODES } from \"../events/events.js\";\nimport type { PluginContext } from \"../types.js\";\n\ninterface AgentStreamConfig {\n  system: string;\n  // AI SDK tool type is opaque and not directly expressible — `any` required here\n  tools: Record<string, any>;\n  prompt?: string;\n  messages?: Array<{ role: \"user\" | \"assistant\"; content: string }>;\n  model?: string;\n  maxSteps?: number;\n  conversationId: string;\n  agentName?: string;\n  extraDoneData?: Record<string, unknown>;\n  onStreamComplete?: (result: { text: string; toolCalls: string[] }) => Promise<void>;\n}\n\nexport function streamAgentResponse(ctx: PluginContext, config: AgentStreamConfig) {\n  const startTime = performance.now();\n  let abortSignal = getAbortSignal();\n  if (!abortSignal) {\n    const controller = registerRequest(config.conversationId);\n    abortSignal = controller.signal;\n  }\n  const promptOrMessages = config.messages\n    ? { messages: [{ role: \"system\" as const, content: config.system }, ...config.messages] }\n    : { system: config.system, prompt: config.prompt! };\n\n  const result = streamText({\n    model: ctx.getModel(config.model),\n    ...promptOrMessages,\n    tools: config.tools,\n    stopWhen: stepCountIs(config.maxSteps ?? ctx.defaultMaxSteps),\n    abortSignal,\n  });\n\n  return createSSEStream(async (writer) => {\n    let id = 0;\n    const toolsUsed = new Set<string>();\n    const bus = getEventBus();\n    let fullText = \"\";\n\n    await writer.writeSSE({\n      id: String(id++),\n      event: SSE_EVENTS.SESSION_START,\n      data: JSON.stringify({ conversationId: config.conversationId }),\n    });\n\n    await writer.writeSSE({\n      id: String(id++),\n      event: SSE_EVENTS.STATUS,\n      data: JSON.stringify({ code: STATUS_CODES.PROCESSING, message: \"Agent starting work\", agent: config.agentName }),\n    });\n\n    try {\n      for await (const chunk of result.fullStream) {\n        if (chunk.type === \"text-delta\") {\n          fullText += chunk.text;\n          bus?.emit(BUS_EVENTS.TEXT_DELTA, { text: chunk.text });\n          await writer.writeSSE({\n            id: String(id++),\n            event: SSE_EVENTS.TEXT_DELTA,\n            data: JSON.stringify({ text: chunk.text }),\n          });\n        } else if (chunk.type === \"tool-call\") {\n          toolsUsed.add(chunk.toolName);\n          bus?.emit(BUS_EVENTS.TOOL_CALL, { agent: config.agentName, tool: chunk.toolName, args: chunk.input });\n          await writer.writeSSE({\n            id: String(id++),\n            event: SSE_EVENTS.TOOL_CALL,\n            data: JSON.stringify({\n              agent: config.agentName,\n              toolName: chunk.toolName,\n              args: chunk.input,\n            }),\n          });\n        } else if (chunk.type === \"tool-result\") {\n          bus?.emit(BUS_EVENTS.TOOL_RESULT, { agent: config.agentName, tool: chunk.toolName, result: chunk.output });\n          await writer.writeSSE({\n            id: String(id++),\n            event: SSE_EVENTS.TOOL_RESULT,\n            data: JSON.stringify({\n              agent: config.agentName,\n              toolName: chunk.toolName,\n              result: chunk.output,\n            }),\n          });\n        }\n      }\n\n      if (config.onStreamComplete) {\n        await config.onStreamComplete({ text: fullText, toolCalls: [...toolsUsed] });\n      }\n\n      const usage = await result.usage;\n      const usageInfo = extractStreamUsage(usage, startTime);\n\n      await writer.writeSSE({\n        id: String(id++),\n        event: SSE_EVENTS.DONE,\n        data: JSON.stringify({\n          toolsUsed: [...toolsUsed],\n          conversationId: config.conversationId,\n          usage: usageInfo,\n          ...config.extraDoneData,\n        }),\n      });\n    } catch (err: unknown) {\n      const message = err instanceof Error ? err.message : String(err);\n      const errName = err instanceof Error ? err.name : undefined;\n      if (errName === \"AbortError\" || abortSignal?.aborted) {\n        await writer.writeSSE({\n          id: String(id++),\n          event: SSE_EVENTS.CANCELLED,\n          data: JSON.stringify({ conversationId: config.conversationId }),\n        });\n      } else {\n        await writer.writeSSE({\n          id: String(id++),\n          event: SSE_EVENTS.ERROR,\n          data: JSON.stringify({ conversationId: config.conversationId, error: message }),\n        });\n      }\n    } finally {\n      unregisterRequest(config.conversationId);\n    }\n  }, abortSignal);\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/streaming/sse-writer.ts",
      "content": "export interface SSEMessage {\n  event: string;\n  data: string;\n  id?: string;\n}\n\nexport interface SSEWriter {\n  writeSSE(message: SSEMessage): Promise<void>;\n  close(): void;\n}\n\n/**\n * Creates a web-standard Response with SSE content.\n * The handler receives an SSEWriter to write events.\n * Returns a Response with Content-Type: text/event-stream.\n */\nexport function createSSEStream(\n  handler: (writer: SSEWriter) => Promise<void>,\n  signal?: AbortSignal,\n): Response {\n  let controller: ReadableStreamDefaultController<Uint8Array>;\n  const encoder = new TextEncoder();\n\n  const stream = new ReadableStream<Uint8Array>({\n    start(ctrl) {\n      controller = ctrl;\n    },\n    cancel() {\n      // Stream was cancelled by the client\n    },\n  });\n\n  const writer: SSEWriter = {\n    async writeSSE({ event, data, id }) {\n      let message = \"\";\n      if (id) message += `id: ${id}\\n`;\n      message += `event: ${event}\\n`;\n      message += `data: ${data}\\n\\n`;\n      try {\n        controller.enqueue(encoder.encode(message));\n      } catch {\n        // Stream may be closed\n      }\n    },\n    close() {\n      try {\n        controller.close();\n      } catch {\n        // Already closed\n      }\n    },\n  };\n\n  // Run the handler asynchronously\n  handler(writer)\n    .catch(() => {})\n    .finally(() => writer.close());\n\n  // Handle abort\n  if (signal) {\n    signal.addEventListener(\"abort\", () => writer.close(), { once: true });\n  }\n\n  return new Response(stream, {\n    headers: {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n    },\n  });\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/types.ts",
      "content": "import type { LanguageModel } from \"ai\";\nimport type { AgentRegistry } from \"./registry/agent-registry.js\";\nexport type { AgentRegistry };\nimport type { ToolRegistry } from \"./registry/tool-registry.js\";\nimport type { StorageProvider } from \"./storage/interfaces.js\";\nimport type { VoiceManager } from \"./voice/voice-manager.js\";\nimport type { CardRegistry } from \"./utils/card-registry.js\";\n\n/**\n * Framework-agnostic request interface.\n * Adapters (Hono, Express, etc.) convert their native request objects\n * into this shape before calling core handlers.\n */\nexport interface AgentRequest {\n  json<T = unknown>(): Promise<T>;\n  query(key: string): string | undefined;\n  param(key: string): string;\n  header(key: string): string | undefined;\n  /** The raw Web API Request (for access to .signal, etc.) */\n  raw: Request;\n}\n\nexport interface ResilienceConfig {\n  /** Max retry attempts before invoking fallback (default: 3) */\n  maxRetries?: number;\n  /** Base delay in ms for exponential backoff (default: 1000) */\n  baseDelayMs?: number;\n  /** Max delay cap in ms (default: 30000) */\n  maxDelayMs?: number;\n  /** Jitter factor 0-1 to randomize delay (default: 0.2) */\n  jitterFactor?: number;\n  /** Fallback interceptor. Return a new model ID to retry, or null to abort. */\n  onFallback?: (context: FallbackContext) => string | null | Promise<string | null>;\n}\n\nexport interface FallbackContext {\n  agent?: string;\n  currentModel: string;\n  retryCount: number;\n  error: Error;\n}\n\nexport interface CompactionConfig {\n  /** Auto-compact when message count exceeds threshold (default: 20) */\n  threshold?: number;\n  /** Number of recent messages to preserve (default: 4) */\n  preserveRecent?: number;\n  /** Custom system prompt for summarization LLM call */\n  prompt?: string;\n  /** Model to use for compaction (defaults to plugin default) */\n  model?: string;\n  /** Enable/disable auto-compaction (default: true when config provided) */\n  enabled?: boolean;\n}\n\n/** Core configuration — framework-agnostic. */\nexport interface CoreConfig {\n  /** Returns a LanguageModel for the given model ID (or default) */\n  getModel: (id?: string) => LanguageModel;\n  /** Storage provider. Defaults to in-memory (ephemeral) if omitted. */\n  storage?: StorageProvider;\n  /** Maximum delegation nesting depth (default: 3) */\n  maxDelegationDepth?: number;\n  /** Default max AI SDK steps per agent call (default: 5) */\n  defaultMaxSteps?: number;\n  /** Resilience configuration for LLM call retries and fallback */\n  resilience?: ResilienceConfig;\n  /** Conversation compaction configuration */\n  compaction?: CompactionConfig;\n}\n\n/** Internal context passed to all core handlers and factories. */\nexport interface PluginContext {\n  agents: AgentRegistry;\n  tools: ToolRegistry;\n  storage: StorageProvider;\n  getModel: (id?: string) => LanguageModel;\n  voice?: VoiceManager;\n  cards: CardRegistry;\n  maxDelegationDepth: number;\n  defaultMaxSteps: number;\n  config: CoreConfig;\n}\n\n",
      "type": "kitn:package"
    },
    {
      "path": "core/voice/voice-provider.ts",
      "content": "export interface VoiceProvider {\n  readonly name: string;\n  readonly label: string;\n  transcribe(audio: Blob | Buffer, options?: TranscribeOptions): Promise<TranscribeResult>;\n  speak(text: string, options?: SpeakOptions): Promise<ReadableStream<Uint8Array>>;\n  getSpeakers(): Promise<VoiceSpeaker[]>;\n}\n\nexport interface TranscribeOptions {\n  language?: string;\n  prompt?: string;\n  model?: string;\n}\n\nexport interface TranscribeResult {\n  text: string;\n  language?: string;\n  duration?: number;\n}\n\nexport interface SpeakOptions {\n  speaker?: string;\n  format?: \"mp3\" | \"opus\" | \"wav\" | \"aac\" | \"flac\";\n  speed?: number;\n  model?: string;\n}\n\nexport interface VoiceSpeaker {\n  voiceId: string;\n  name: string;\n  [key: string]: unknown;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/voice/voice-manager.ts",
      "content": "import type { VoiceProvider } from \"./voice-provider.js\";\n\nexport class VoiceManager {\n  private providers = new Map<string, VoiceProvider>();\n  private defaultProvider: string | null = null;\n\n  register(provider: VoiceProvider) {\n    this.providers.set(provider.name, provider);\n    if (!this.defaultProvider) {\n      this.defaultProvider = provider.name;\n    }\n  }\n\n  get(name?: string): VoiceProvider | undefined {\n    return this.providers.get(name ?? this.defaultProvider ?? \"\");\n  }\n\n  list(): VoiceProvider[] {\n    return [...this.providers.values()];\n  }\n\n  listNames(): string[] {\n    return [...this.providers.keys()];\n  }\n\n  getDefault(): string | null {\n    return this.defaultProvider;\n  }\n\n  isAvailable(): boolean {\n    return this.providers.size > 0;\n  }\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/voice/openai-voice-provider.ts",
      "content": "import type {\n  VoiceProvider,\n  TranscribeOptions,\n  TranscribeResult,\n  SpeakOptions,\n  VoiceSpeaker,\n} from \"./voice-provider.js\";\n\nconst OPENAI_BASE = \"https://api.openai.com/v1\";\n\nconst VOICES: VoiceSpeaker[] = [\n  { voiceId: \"alloy\", name: \"Alloy\", description: \"Neutral and balanced\" },\n  { voiceId: \"echo\", name: \"Echo\", description: \"Warm and clear\" },\n  { voiceId: \"fable\", name: \"Fable\", description: \"Expressive and animated\" },\n  { voiceId: \"onyx\", name: \"Onyx\", description: \"Deep and authoritative\" },\n  { voiceId: \"nova\", name: \"Nova\", description: \"Friendly and upbeat\" },\n  { voiceId: \"shimmer\", name: \"Shimmer\", description: \"Gentle and calm\" },\n];\n\nexport interface OpenAIVoiceProviderConfig {\n  apiKey: string;\n  baseUrl?: string;\n  name?: string;\n  label?: string;\n  ttsModel?: string;\n  sttModel?: string;\n  defaultSpeaker?: string;\n}\n\nexport class OpenAIVoiceProvider implements VoiceProvider {\n  readonly name: string;\n  readonly label: string;\n\n  private apiKey: string;\n  private baseUrl: string;\n  private ttsModel: string;\n  private sttModel: string;\n  private defaultSpeaker: string;\n\n  constructor(config: OpenAIVoiceProviderConfig) {\n    this.name = config.name ?? \"openai\";\n    this.label = config.label ?? \"OpenAI\";\n    this.apiKey = config.apiKey;\n    this.baseUrl = (config.baseUrl ?? OPENAI_BASE).replace(/\\/$/, \"\");\n    this.ttsModel = config.ttsModel ?? \"tts-1\";\n    this.sttModel = config.sttModel ?? \"gpt-4o-mini-transcribe\";\n    this.defaultSpeaker = config.defaultSpeaker ?? \"alloy\";\n  }\n\n  async transcribe(audio: Blob | Buffer, options?: TranscribeOptions): Promise<TranscribeResult> {\n    const form = new FormData();\n\n    // Always re-buffer to a fresh Blob to avoid Bun runtime issues\n    // where File objects from parsed formData can't be re-sent reliably\n    let blob: Blob;\n    if (audio instanceof Blob) {\n      const buffer = await audio.arrayBuffer();\n      blob = new Blob([buffer], { type: (audio as File).type || \"audio/webm\" });\n    } else {\n      blob = new Blob([new Uint8Array(audio)], { type: \"audio/webm\" });\n    }\n    form.append(\"file\", blob, \"audio.webm\");\n    form.append(\"model\", options?.model ?? this.sttModel);\n    if (options?.language) form.append(\"language\", options.language);\n    if (options?.prompt) form.append(\"prompt\", options.prompt);\n    form.append(\"response_format\", \"verbose_json\");\n\n    const res = await fetch(`${this.baseUrl}/audio/transcriptions`, {\n      method: \"POST\",\n      headers: { Authorization: `Bearer ${this.apiKey}` },\n      body: form,\n    });\n\n    if (!res.ok) {\n      const error = await res.text();\n      throw new Error(`OpenAI STT failed (${res.status}): ${error}`);\n    }\n\n    const data = await res.json();\n    return { text: data.text, language: data.language, duration: data.duration };\n  }\n\n  async speak(text: string, options?: SpeakOptions): Promise<ReadableStream<Uint8Array>> {\n    const format = options?.format ?? \"mp3\";\n    const speaker = options?.speaker ?? this.defaultSpeaker;\n    const speed = options?.speed ?? 1.0;\n\n    const res = await fetch(`${this.baseUrl}/audio/speech`, {\n      method: \"POST\",\n      headers: { Authorization: `Bearer ${this.apiKey}`, \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        model: options?.model ?? this.ttsModel,\n        input: text,\n        voice: speaker,\n        response_format: format,\n        speed,\n      }),\n    });\n\n    if (!res.ok) {\n      const error = await res.text();\n      throw new Error(`OpenAI TTS failed (${res.status}): ${error}`);\n    }\n\n    if (!res.body) throw new Error(\"OpenAI TTS returned no body\");\n    return res.body as ReadableStream<Uint8Array>;\n  }\n\n  async getSpeakers(): Promise<VoiceSpeaker[]> {\n    return VOICES;\n  }\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/registry/agent-registry.ts",
      "content": "import type { AgentRequest } from \"../types.js\";\nimport type { z } from \"zod\";\n\nexport type AgentHandler = (\n  req: AgentRequest,\n  options: { systemPrompt: string; memoryContext?: string },\n) => Response | Promise<Response>;\n\nexport interface GuardResult {\n  allowed: boolean;\n  reason?: string;\n}\n\nexport interface ActionRegistration {\n  name: string;\n  method: \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n  summary: string;\n  description: string;\n  handler: (req: AgentRequest) => Response | Promise<Response>;\n  requestSchema?: z.ZodType<any>;\n}\n\nexport interface AgentRegistration {\n  name: string;\n  description: string;\n  tags?: string[];\n  toolNames: string[];\n  defaultFormat: \"json\" | \"sse\";\n  defaultSystem: string;\n  tools?: Record<string, any>;\n  jsonHandler?: AgentHandler;\n  sseHandler?: AgentHandler;\n  actions?: ActionRegistration[];\n  /** Explicit list of agent names this orchestrator routes to (omit for auto-discovery) */\n  agents?: string[];\n  /** Marks agent as an orchestrator — orchestrators cannot be delegated to */\n  isOrchestrator?: boolean;\n  /** Disable the built-in _memory tool for this agent (default: false) */\n  disableMemoryTool?: boolean;\n  /** Pre-execution guard. Called with the query before the agent runs.\n   *  Return { allowed: false, reason } to block execution. */\n  guard?: (query: string, agent: string) => GuardResult | Promise<GuardResult>;\n}\n\nexport class AgentRegistry {\n  private agents = new Map<string, AgentRegistration>();\n  private promptOverrides = new Map<string, string>();\n\n  register(registration: AgentRegistration) {\n    this.agents.set(registration.name, registration);\n  }\n\n  get(name: string): AgentRegistration | undefined {\n    return this.agents.get(name);\n  }\n\n  list(): AgentRegistration[] {\n    return [...this.agents.values()];\n  }\n\n  getResolvedPrompt(name: string): string | undefined {\n    const agent = this.agents.get(name);\n    if (!agent) return undefined;\n    return this.promptOverrides.get(name) ?? agent.defaultSystem;\n  }\n\n  setPromptOverride(name: string, prompt: string) {\n    this.promptOverrides.set(name, prompt);\n  }\n\n  resetPrompt(name: string) {\n    this.promptOverrides.delete(name);\n  }\n\n  hasPromptOverride(name: string): boolean {\n    return this.promptOverrides.has(name);\n  }\n\n  /** Returns the set of agent names that are marked as orchestrators */\n  getOrchestratorNames(): Set<string> {\n    const names = new Set<string>();\n    for (const agent of this.agents.values()) {\n      if (agent.isOrchestrator) names.add(agent.name);\n    }\n    return names;\n  }\n\n  loadPromptOverrides(overrides: Record<string, string>) {\n    for (const [name, prompt] of Object.entries(overrides)) {\n      this.promptOverrides.set(name, prompt);\n    }\n  }\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/registry/tool-registry.ts",
      "content": "import type { z } from \"zod\";\nimport type { ToolExample } from \"../utils/tool-examples.js\";\n\nexport interface ToolRegistration {\n  name: string;\n  description: string;\n  inputSchema: z.ZodType<any>;\n  // AI SDK tool type is opaque and not directly expressible — `any` required here\n  tool: any;\n  directExecute?: (input: any) => Promise<any>;\n  category?: string;\n  /** Structured examples for improved tool use accuracy */\n  examples?: ToolExample[];\n}\n\nexport class ToolRegistry {\n  private tools = new Map<string, ToolRegistration>();\n\n  register(registration: ToolRegistration) {\n    this.tools.set(registration.name, registration);\n  }\n\n  get(name: string): ToolRegistration | undefined {\n    return this.tools.get(name);\n  }\n\n  list(): ToolRegistration[] {\n    return [...this.tools.values()];\n  }\n\n  async execute(name: string, input: unknown): Promise<unknown> {\n    const registration = this.tools.get(name);\n    if (!registration) {\n      throw new Error(`Tool not found: ${name}`);\n    }\n    if (registration.directExecute) {\n      return registration.directExecute(input);\n    }\n    return registration.tool.execute!(input, { toolCallId: \"direct\" } as any);\n  }\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/registry/handler-factories.ts",
      "content": "import type { AgentRequest } from \"../types.js\";\nimport type { PluginContext } from \"../types.js\";\nimport type { AgentHandler } from \"./agent-registry.js\";\nimport { loadConversationWithCompaction } from \"../utils/conversation-helpers.js\";\n\nexport function generateConversationId(existing?: string) {\n  return existing ?? `conv_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n}\n\ninterface RegistryHandlerConfig {\n  tools: Record<string, any>;\n  maxSteps?: number;\n}\n\nexport function makeRegistryStreamHandler(config: RegistryHandlerConfig, ctx: PluginContext): AgentHandler {\n  return async (req: AgentRequest, { systemPrompt, memoryContext }) => {\n    const { streamAgentResponse } = await import(\"../streaming/stream-helpers.js\");\n    const { message, messages, conversationId: cid, model } = await req.json<any>();\n    const convId = generateConversationId(cid);\n\n    const system = memoryContext\n      ? `${systemPrompt}\\n\\n## Memory Context\\n${memoryContext}`\n      : systemPrompt;\n\n    // If a conversationId is provided, load history (with auto-compaction) from the store\n    let historyMessages: Array<{ role: \"user\" | \"assistant\"; content: string }> | undefined;\n    if (cid) {\n      historyMessages = await loadConversationWithCompaction(ctx, cid, message);\n    }\n\n    const promptOrMessages = historyMessages\n      ? { messages: historyMessages }\n      : messages\n        ? { messages }\n        : { prompt: message };\n\n    return streamAgentResponse(ctx, {\n      system,\n      tools: config.tools,\n      ...promptOrMessages,\n      model,\n      maxSteps: config.maxSteps,\n      conversationId: convId,\n      onStreamComplete: cid\n        ? async ({ text }) => {\n            if (text) {\n              await ctx.storage.conversations.append(cid, {\n                role: \"assistant\",\n                content: text,\n                timestamp: new Date().toISOString(),\n              });\n            }\n          }\n        : undefined,\n    });\n  };\n}\n\nexport function makeRegistryJsonHandler(config: RegistryHandlerConfig, ctx: PluginContext): AgentHandler {\n  return async (req: AgentRequest, { systemPrompt, memoryContext }) => {\n    const { runAgent } = await import(\"../agents/run-agent.js\");\n    const { message, conversationId: cid, model } = await req.json<any>();\n\n    const system = memoryContext\n      ? `${systemPrompt}\\n\\n## Memory Context\\n${memoryContext}`\n      : systemPrompt;\n\n    const result = await runAgent(\n      ctx,\n      { system, tools: config.tools },\n      message,\n      model,\n      config.maxSteps,\n    );\n    return new Response(JSON.stringify({ ...result, conversationId: generateConversationId(cid) }), {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  };\n}\n\nexport function makeRegistryHandlers(config: RegistryHandlerConfig, ctx: PluginContext) {\n  return {\n    sseHandler: makeRegistryStreamHandler(config, ctx),\n    jsonHandler: makeRegistryJsonHandler(config, ctx),\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/registry/index.ts",
      "content": "export { AgentRegistry } from \"./agent-registry.js\";\nexport type { AgentRegistration, AgentHandler, ActionRegistration, GuardResult } from \"./agent-registry.js\";\nexport { ToolRegistry } from \"./tool-registry.js\";\nexport type { ToolRegistration } from \"./tool-registry.js\";\nexport { makeRegistryHandlers, makeRegistryStreamHandler, makeRegistryJsonHandler, generateConversationId } from \"./handler-factories.js\";\n",
      "type": "kitn:package"
    },
    {
      "path": "core/index.ts",
      "content": "// ── Core types ──\nexport type { AgentRequest, CoreConfig, PluginContext, ResilienceConfig, FallbackContext, CompactionConfig } from \"./types.js\";\n\n// ── Registry ──\nexport { AgentRegistry } from \"./registry/agent-registry.js\";\nexport { ToolRegistry } from \"./registry/tool-registry.js\";\nexport { makeRegistryHandlers, makeRegistryStreamHandler, makeRegistryJsonHandler, generateConversationId } from \"./registry/handler-factories.js\";\nexport type { AgentRegistration, AgentHandler, ActionRegistration, GuardResult } from \"./registry/agent-registry.js\";\nexport type { ToolRegistration } from \"./registry/tool-registry.js\";\n\n// ── Agent utilities ──\nexport { createOrchestratorAgent, DEFAULT_ORCHESTRATOR_PROMPT } from \"./agents/orchestrator.js\";\nexport type { OrchestratorAgentConfig } from \"./agents/orchestrator.js\";\nexport { executeTask } from \"./agents/execute-task.js\";\nexport type { TaskResult, ClarifyItem } from \"./agents/execute-task.js\";\nexport { createMemoryTool, getDefaultMemoryStore, setDefaultMemoryStore } from \"./agents/memory-tool.js\";\nexport { runAgent } from \"./agents/run-agent.js\";\n\n// ── Events ──\nexport { AgentEventBus } from \"./events/agent-events.js\";\nexport type { AgentEvent } from \"./events/agent-events.js\";\nexport { SSE_EVENTS, BUS_EVENTS, BUS_TO_SSE_MAP, FORWARDED_BUS_EVENTS, STATUS_CODES } from \"./events/events.js\";\nexport type { SseEventName, BusEventName, StatusCode } from \"./events/events.js\";\nexport { emitStatus, writeStatus } from \"./events/emit-status.js\";\nexport type { StatusPayload } from \"./events/emit-status.js\";\n\n// ── Constants ──\nexport { TOOL_NAMES, DEFAULTS } from \"./utils/constants.js\";\n\n// ── Card registry ──\nexport { CardRegistry } from \"./utils/card-registry.js\";\nexport type { CardData, CardExtractor } from \"./utils/card-registry.js\";\n\n// ── AI provider utilities ──\nexport type { UsageInfo } from \"./utils/ai-provider.js\";\nexport { extractUsage, extractStreamUsage, mergeUsage } from \"./utils/ai-provider.js\";\n\n// ── Delegation context ──\nexport { delegationStore, getEventBus, getAbortSignal } from \"./utils/delegation-context.js\";\nexport type { DelegationContext } from \"./utils/delegation-context.js\";\n\n// ── Request registry ──\nexport { registerRequest, cancelRequest, unregisterRequest } from \"./utils/request-registry.js\";\n\n// ── Streaming ──\nexport { streamAgentResponse } from \"./streaming/stream-helpers.js\";\nexport { createSSEStream } from \"./streaming/sse-writer.js\";\nexport type { SSEWriter, SSEMessage } from \"./streaming/sse-writer.js\";\n\n// ── Storage ──\nexport type {\n  StorageProvider,\n  ConversationStore,\n  ConversationMessage,\n  Conversation,\n  ConversationSummary,\n  MemoryStore,\n  MemoryEntry,\n  SkillStore,\n  SkillMeta,\n  Skill,\n  SkillPhase,\n  TaskStore,\n  Task,\n  PromptStore,\n  PromptOverride,\n  AudioStore,\n  AudioEntry,\n} from \"./storage/interfaces.js\";\nexport { createFileStorage } from \"./storage/file-storage/index.js\";\nexport type { FileStorageOptions } from \"./storage/file-storage/index.js\";\nexport { createMemoryStorage } from \"./storage/in-memory/index.js\";\nexport { createInMemoryMemoryStore } from \"./storage/in-memory/memory-store.js\";\n\n// ── Tool examples ──\nexport type { ToolExample } from \"./utils/tool-examples.js\";\nexport { formatExamplesBlock, buildToolDescription } from \"./utils/tool-examples.js\";\n\n// ── Voice ──\nexport type { VoiceProvider, TranscribeOptions, TranscribeResult, SpeakOptions, VoiceSpeaker } from \"./voice/voice-provider.js\";\nexport { VoiceManager } from \"./voice/voice-manager.js\";\nexport { OpenAIVoiceProvider } from \"./voice/openai-voice-provider.js\";\nexport type { OpenAIVoiceProviderConfig } from \"./voice/openai-voice-provider.js\";\n\n// ── Resilience ──\nexport { withResilience, isRetryableError } from \"./utils/resilience.js\";\n\n// ── Compaction ──\nexport { compactConversation, needsCompaction, COMPACTION_METADATA_KEY } from \"./utils/compaction.js\";\nexport type { CompactionResult } from \"./utils/compaction.js\";\n\n// ── Conversation helpers ──\nexport { loadConversationWithCompaction } from \"./utils/conversation-helpers.js\";\n\n// ── Schemas ──\nexport { generateRequestSchema, generateResponseSchema } from \"./schemas/generate.schemas.js\";\nexport { agentRequestSchema, agentResponseSchema, approveRequestSchema, agentPatchSchema } from \"./schemas/agents.schemas.js\";\nexport { memoryEntrySchema, memorySaveSchema } from \"./schemas/memory.schemas.js\";\nexport { skillMetaSchema, skillSchema, skillCreateSchema, skillUpdateSchema } from \"./schemas/skills.schemas.js\";\nexport { speakRequestSchema, transcribeResponseSchema, speakersResponseSchema, converseResponseHeadersSchema } from \"./schemas/voice.schemas.js\";\n",
      "type": "kitn:package"
    },
    {
      "path": "core/events/emit-status.ts",
      "content": "import { getEventBus } from \"../utils/delegation-context.js\";\nimport { BUS_EVENTS, SSE_EVENTS } from \"./events.js\";\nimport type { StatusCode } from \"./events.js\";\n\nexport interface StatusPayload {\n  code: StatusCode;\n  message: string;\n  agent?: string;\n  metadata?: Record<string, unknown>;\n}\n\ninterface StreamWriter {\n  write(event: string, data: Record<string, unknown>): Promise<void>;\n}\n\n/** Emit a status event on the internal bus (for sub-agents, resilience, compaction). */\nexport function emitStatus(payload: StatusPayload): void {\n  getEventBus()?.emit(BUS_EVENTS.STATUS, payload as unknown as Record<string, unknown>);\n}\n\n/** Write a status event directly to an SSE stream writer (for orchestrator top-level). */\nexport async function writeStatus(writer: StreamWriter, payload: StatusPayload): Promise<void> {\n  await writer.write(SSE_EVENTS.STATUS, payload as unknown as Record<string, unknown>);\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "core/events/events.ts",
      "content": "/** SSE event names sent to clients over Server-Sent Events */\nexport const SSE_EVENTS = {\n  SESSION_START: \"session:start\",\n  TEXT_DELTA: \"text-delta\",\n  TOOL_CALL: \"tool-call\",\n  TOOL_RESULT: \"tool-result\",\n  DONE: \"done\",\n  CANCELLED: \"cancelled\",\n  AGENT_START: \"agent:start\",\n  AGENT_END: \"agent:end\",\n  AGENT_THINK: \"agent:think\",\n  AGENT_PLAN: \"agent:plan\",\n  ASK_USER: \"ask:user\",\n  DELEGATE_START: \"delegate:start\",\n  DELEGATE_END: \"delegate:end\",\n  SKILL_INJECT: \"skill:inject\",\n  STATUS: \"status\",\n  ERROR: \"error\",\n} as const;\n\nexport type SseEventName = (typeof SSE_EVENTS)[keyof typeof SSE_EVENTS];\n\n/** Internal bus event names emitted between agents via AgentEventBus */\nexport const BUS_EVENTS = {\n  TEXT_DELTA: \"text:delta\",\n  TOOL_CALL: \"tool:call\",\n  TOOL_RESULT: \"tool:result\",\n  AGENT_START: \"agent:start\",\n  AGENT_END: \"agent:end\",\n  DELEGATE_START: \"delegate:start\",\n  DELEGATE_END: \"delegate:end\",\n  SKILL_INJECT: \"skill:inject\",\n  STATUS: \"status\",\n} as const;\n\nexport type BusEventName = (typeof BUS_EVENTS)[keyof typeof BUS_EVENTS];\n\n/** Maps internal bus event names to their corresponding SSE event names */\nexport const BUS_TO_SSE_MAP: Record<string, string> = {\n  [BUS_EVENTS.AGENT_START]: SSE_EVENTS.AGENT_START,\n  [BUS_EVENTS.AGENT_END]: SSE_EVENTS.AGENT_END,\n  [BUS_EVENTS.DELEGATE_START]: SSE_EVENTS.DELEGATE_START,\n  [BUS_EVENTS.DELEGATE_END]: SSE_EVENTS.DELEGATE_END,\n  [BUS_EVENTS.TOOL_CALL]: SSE_EVENTS.TOOL_CALL,\n  [BUS_EVENTS.TOOL_RESULT]: SSE_EVENTS.TOOL_RESULT,\n  [BUS_EVENTS.SKILL_INJECT]: SSE_EVENTS.SKILL_INJECT,\n  [BUS_EVENTS.STATUS]: SSE_EVENTS.STATUS,\n};\n\n/** Set of bus event names that are forwarded to SSE clients */\nexport const FORWARDED_BUS_EVENTS = new Set(Object.keys(BUS_TO_SSE_MAP));\n\n/** Typed status codes for the `status` event */\nexport const STATUS_CODES = {\n  THINKING: \"thinking\",\n  PLANNING: \"planning\",\n  EXECUTING_TASKS: \"executing-tasks\",\n  SYNTHESIZING: \"synthesizing\",\n  COMPACTING: \"compacting\",\n  RETRYING: \"retrying\",\n  FALLBACK: \"fallback\",\n  GUARD_CHECK: \"guard-check\",\n  LOADING_CONTEXT: \"loading-context\",\n  PROCESSING: \"processing\",\n} as const;\n\nexport type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];\n",
      "type": "kitn:package"
    },
    {
      "path": "core/events/agent-events.ts",
      "content": "export interface AgentEvent {\n  type: string;\n  data: Record<string, unknown>;\n  timestamp: number;\n}\n\ntype EventHandler = (event: AgentEvent) => void | Promise<void>;\n\nexport class AgentEventBus {\n  private handlers: EventHandler[] = [];\n\n  subscribe(handler: EventHandler): () => void {\n    this.handlers.push(handler);\n    return () => {\n      const idx = this.handlers.indexOf(handler);\n      if (idx >= 0) this.handlers.splice(idx, 1);\n    };\n  }\n\n  emit(type: string, data: Record<string, unknown> = {}): void {\n    const event: AgentEvent = { type, data, timestamp: Date.now() };\n    for (const handler of this.handlers) {\n      try {\n        handler(event);\n      } catch (err) {\n        console.error(\"[agent-events] handler error:\", err);\n      }\n    }\n  }\n}\n",
      "type": "kitn:package"
    }
  ],
  "installDir": "core",
  "tsconfig": {
    "@kitnai/core": [
      "./index.ts"
    ]
  },
  "docs": "Engine installed to your project. Import with: import { ... } from '@kitnai/core'",
  "version": "1.0.0",
  "updatedAt": "2026-02-25T18:59:36.512Z"
}
