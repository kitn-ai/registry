{
  "$schema": "https://kitn.dev/schema/registry-item.json",
  "name": "hono",
  "type": "kitn:package",
  "description": "Hono HTTP adapter with routes for kitn AI agents",
  "dependencies": [
    "hono",
    "@hono/zod-openapi",
    "@scalar/hono-api-reference"
  ],
  "registryDependencies": [
    "core"
  ],
  "files": [
    {
      "path": "routes/plugin.ts",
      "content": "import { OpenAPIHono } from \"@hono/zod-openapi\";\nimport { HTTPException } from \"hono/http-exception\";\nimport type { AIPluginConfig, AIPluginInstance } from \"./types.js\";\nimport type { PluginContext } from \"@kitnai/core\";\nimport {\n  AgentRegistry,\n  ToolRegistry,\n  CardRegistry,\n  DEFAULTS,\n  setDefaultMemoryStore,\n  makeRegistryHandlers,\n  createOrchestratorAgent,\n  createMemoryStorage,\n  VoiceManager,\n} from \"@kitnai/core\";\nimport { configureOpenAPI } from \"./lib/configure-openapi.js\";\n\n// Route factories\nimport { createHealthRoutes } from \"./routes/health/health.route.js\";\nimport { createAgentsRoutes } from \"./routes/agents/agents.routes.js\";\nimport { createToolsRoutes } from \"./routes/tools/tools.routes.js\";\nimport { createGenerateRoutes } from \"./routes/generate/generate.routes.js\";\nimport { createMemoryRoutes } from \"./routes/memory/memory.routes.js\";\nimport { createSkillsRoutes } from \"./routes/skills/skills.routes.js\";\nimport { createConversationsRoutes } from \"./routes/conversations/conversations.routes.js\";\nimport { createVoiceRoutes } from \"./routes/voice/voice.routes.js\";\n\nexport function createAIPlugin(config: AIPluginConfig): AIPluginInstance {\n  if (config.memoryStore) {\n    setDefaultMemoryStore(config.memoryStore);\n  }\n\n  const storage = config.storage ?? (() => {\n    console.log(\"[ai-plugin] Using in-memory storage (data will not persist across restarts)\");\n    return createMemoryStorage();\n  })();\n\n  const agents = new AgentRegistry();\n  const tools = new ToolRegistry();\n  const cards = new CardRegistry();\n  const voice = config.voice ? new VoiceManager() : undefined;\n\n  const ctx: PluginContext = {\n    agents,\n    tools,\n    storage,\n    getModel: config.getModel,\n    voice,\n    cards,\n    maxDelegationDepth: config.maxDelegationDepth ?? DEFAULTS.MAX_DELEGATION_DEPTH,\n    defaultMaxSteps: config.defaultMaxSteps ?? DEFAULTS.MAX_STEPS,\n    config,\n  };\n\n  // Build the Hono sub-app\n  const app = new OpenAPIHono();\n\n  app.onError((err, c) => {\n    if (err instanceof HTTPException) {\n      return c.json({ error: err.message }, err.status);\n    }\n    console.error(err);\n    return c.json({ error: \"Internal Server Error\" }, 500);\n  });\n\n  app.notFound((c) => {\n    return c.json({ error: \"Not Found\" }, 404);\n  });\n\n  // Health check\n  app.route(\"/health\", createHealthRoutes(ctx));\n\n  // Mount API routes\n  app.route(\"/generate\", createGenerateRoutes(ctx));\n  app.route(\"/tools\", createToolsRoutes(ctx));\n  app.route(\"/agents\", createAgentsRoutes(ctx));\n  app.route(\"/memory\", createMemoryRoutes(ctx));\n  app.route(\"/skills\", createSkillsRoutes(ctx));\n  app.route(\"/conversations\", createConversationsRoutes(ctx));\n\n  // Conditionally mount voice routes\n  if (voice) {\n    app.route(\"/voice\", createVoiceRoutes(ctx));\n  }\n\n  // Configure OpenAPI docs\n  configureOpenAPI(app, config.openapi);\n\n  return {\n    app,\n    agents,\n    tools,\n    cards,\n    voice,\n    async initialize() {\n      // Load persisted prompt overrides\n      const overrides = await storage.prompts.loadOverrides();\n      const overrideMap: Record<string, string> = {};\n      for (const [name, entry] of Object.entries(overrides)) {\n        overrideMap[name] = entry.prompt;\n      }\n      agents.loadPromptOverrides(overrideMap);\n\n      const skills = await storage.skills.listSkills();\n      console.log(\n        `[ai-plugin] Initialized: ${agents.list().length} agents, ${tools.list().length} tools, ${skills.length} skills`,\n      );\n    },\n    createHandlers(handlerConfig) {\n      return makeRegistryHandlers(handlerConfig, ctx);\n    },\n    createOrchestrator(orchestratorConfig) {\n      return createOrchestratorAgent(ctx, orchestratorConfig);\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/types.ts",
      "content": "import type { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type {\n  CoreConfig,\n  AgentRegistry,\n  ToolRegistry,\n  AgentHandler,\n  AgentRegistration,\n  CardRegistry,\n  VoiceManager,\n  StorageProvider,\n  MemoryStore,\n  OrchestratorAgentConfig,\n} from \"@kitnai/core\";\n\nexport interface AIPluginConfig extends CoreConfig {\n  voice?: VoiceConfig;\n  memoryStore?: MemoryStore;\n  openapi?: { title?: string; version?: string; description?: string; serverUrl?: string };\n}\n\nexport interface VoiceConfig {\n  retainAudio?: boolean;\n}\n\nexport interface AIPluginInstance {\n  app: OpenAPIHono;\n  agents: AgentRegistry;\n  tools: ToolRegistry;\n  cards: CardRegistry;\n  voice?: VoiceManager;\n  initialize(): Promise<void>;\n  createHandlers(config: { tools: Record<string, any>; maxSteps?: number }): {\n    sseHandler: AgentHandler;\n    jsonHandler: AgentHandler;\n  };\n  createOrchestrator(config: OrchestratorAgentConfig): AgentRegistration;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/adapters/request-adapter.ts",
      "content": "import type { Context } from \"hono\";\nimport type { AgentRequest } from \"@kitnai/core\";\n\n/** Converts a Hono Context into the framework-agnostic AgentRequest interface */\nexport function toAgentRequest(c: Context): AgentRequest {\n  return {\n    json: <T>() => c.req.json<T>(),\n    query: (key: string) => c.req.query(key),\n    param: (key: string) => c.req.param(key),\n    header: (key: string) => c.req.header(key),\n    raw: c.req.raw,\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/lib/configure-openapi.ts",
      "content": "import { apiReference } from \"@scalar/hono-api-reference\";\nimport type { OpenAPIHono } from \"@hono/zod-openapi\";\n\nexport interface OpenAPIConfig {\n  title?: string;\n  version?: string;\n  description?: string;\n  serverUrl?: string;\n}\n\nexport function configureOpenAPI(app: OpenAPIHono, config: OpenAPIConfig = {}) {\n  const {\n    title = \"AI Plugin API\",\n    version = \"1.0.0\",\n    description = \"AI agent framework API\",\n    serverUrl,\n  } = config;\n\n  app.openAPIRegistry.registerComponent(\"securitySchemes\", \"ApiKeyAuth\", {\n    type: \"apiKey\",\n    in: \"header\",\n    name: \"X-API-Key\",\n    description: \"API key required for all routes\",\n  });\n\n  const servers = serverUrl\n    ? [{ url: serverUrl, description: \"Server\" }]\n    : [];\n\n  app.doc(\"/doc\", {\n    openapi: \"3.1.0\",\n    info: { title, version, description },\n    ...(servers.length > 0 && { servers }),\n    security: [{ ApiKeyAuth: [] }],\n  });\n\n  app.get(\n    \"/reference\",\n    apiReference({\n      url: \"/doc\",\n      theme: \"kepler\",\n      layout: \"modern\",\n      defaultHttpClient: { targetKey: \"js\", clientKey: \"fetch\" },\n      pageTitle: `${title} - API Reference`,\n    })\n  );\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/index.ts",
      "content": "// Re-export everything from core for backwards compatibility\nexport * from \"@kitnai/core\";\n\n// Hono-specific exports\nexport { createAIPlugin } from \"./plugin.js\";\nexport type { AIPluginConfig, AIPluginInstance, VoiceConfig } from \"./types.js\";\nexport { toAgentRequest } from \"./adapters/request-adapter.js\";\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/tools/tools.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext } from \"@kitnai/core\";\n\nexport function createToolsRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n\n  router.openapi(\n    createRoute({\n      method: \"get\",\n      path: \"/\",\n      tags: [\"Tools\"],\n      summary: \"List all registered tools\",\n      description: \"Returns metadata for all registered tools including descriptions and input schemas\",\n      responses: {\n        200: {\n          description: \"List of tools\",\n          content: {\n            \"application/json\": {\n              schema: z.object({\n                tools: z.array(z.object({\n                  name: z.string(),\n                  description: z.string(),\n                  category: z.string().optional(),\n                  inputSchema: z.any(),\n                })),\n                count: z.number(),\n              }),\n            },\n          },\n        },\n      },\n    }),\n    (c) => {\n      const tools = ctx.tools.list().map((t) => ({\n        name: t.name, description: t.description, category: t.category, inputSchema: t.inputSchema,\n        ...(t.examples && { examples: t.examples }),\n      }));\n      return c.json({ tools, count: tools.length });\n    },\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"post\",\n      path: \"/{toolName}\",\n      tags: [\"Tools\"],\n      summary: \"Execute a tool by name\",\n      description: \"Runs the named tool with the provided input\",\n      request: {\n        params: z.object({ toolName: z.string().openapi({ example: \"getWeather\" }) }),\n        body: { content: { \"application/json\": { schema: z.any() } } },\n      },\n      responses: {\n        200: { description: \"Tool execution result\", content: { \"application/json\": { schema: z.any() } } },\n        404: { description: \"Tool not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    async (c) => {\n      const name = c.req.param(\"toolName\");\n      const tool = ctx.tools.get(name);\n      if (!tool) return c.json({ error: `Tool not found: ${name}` }, 404);\n      const input = await c.req.json();\n      const result = await ctx.tools.execute(name, input);\n      return c.json(result, 200);\n    },\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/memory/memory.handlers.ts",
      "content": "import type { Context } from \"hono\";\nimport type { PluginContext } from \"@kitnai/core\";\n\nexport function createMemoryHandlers(ctx: PluginContext) {\n  const store = ctx.storage.memory;\n\n  return {\n    async handleListNamespaces(c: Context) {\n      const namespaces = await store.listNamespaces();\n      return c.json({ namespaces, count: namespaces.length }, 200);\n    },\n\n    async handleListEntries(c: Context) {\n      const id = c.req.param(\"id\");\n      const entries = await store.listEntries(id);\n      return c.json({ entries, count: entries.length }, 200);\n    },\n\n    async handleSaveEntry(c: Context) {\n      const id = c.req.param(\"id\");\n      const { key, value, context } = await c.req.json();\n      const entry = await store.saveEntry(id, key, value, context ?? \"\");\n      return c.json(entry, 200);\n    },\n\n    async handleGetEntry(c: Context) {\n      const id = c.req.param(\"id\");\n      const key = c.req.param(\"key\");\n      const entry = await store.getEntry(id, key);\n      if (!entry) return c.json({ error: \"Entry not found\" }, 404);\n      return c.json(entry, 200);\n    },\n\n    async handleDeleteEntry(c: Context) {\n      const id = c.req.param(\"id\");\n      const key = c.req.param(\"key\");\n      const deleted = await store.deleteEntry(id, key);\n      if (!deleted) return c.json({ error: \"Entry not found\" }, 404);\n      return c.json({ deleted: true, namespace: id, key }, 200);\n    },\n\n    async handleClearNamespace(c: Context) {\n      const id = c.req.param(\"id\");\n      await store.clearNamespace(id);\n      return c.json({ cleared: true, namespace: id }, 200);\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/memory/memory.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext } from \"@kitnai/core\";\nimport { memoryEntrySchema, memorySaveSchema } from \"@kitnai/core\";\nimport { createMemoryHandlers } from \"./memory.handlers.js\";\n\nexport function createMemoryRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n  const handlers = createMemoryHandlers(ctx);\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/\", tags: [\"Memory\"], summary: \"List all memory namespaces\",\n      responses: { 200: { description: \"All namespaces\", content: { \"application/json\": { schema: z.object({ namespaces: z.array(z.string()), count: z.number() }) } } } },\n    }),\n    handlers.handleListNamespaces,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/{id}\", tags: [\"Memory\"], summary: \"List all entries in a namespace\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"user-123\" }) }) },\n      responses: { 200: { description: \"Namespace entries\", content: { \"application/json\": { schema: z.object({ entries: z.array(memoryEntrySchema), count: z.number() }) } } } },\n    }),\n    handlers.handleListEntries,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/{id}\", tags: [\"Memory\"], summary: \"Save a memory entry\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"user-123\" }) }), body: { content: { \"application/json\": { schema: memorySaveSchema } } } },\n      responses: { 200: { description: \"Saved entry\", content: { \"application/json\": { schema: memoryEntrySchema } } } },\n    }),\n    handlers.handleSaveEntry,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/{id}/{key}\", tags: [\"Memory\"], summary: \"Get a specific memory entry\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"user-123\" }), key: z.string().openapi({ example: \"user_name\" }) }) },\n      responses: {\n        200: { description: \"Memory entry\", content: { \"application/json\": { schema: memoryEntrySchema } } },\n        404: { description: \"Entry not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    handlers.handleGetEntry,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"delete\", path: \"/{id}/{key}\", tags: [\"Memory\"], summary: \"Delete a specific memory entry\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"user-123\" }), key: z.string().openapi({ example: \"user_name\" }) }) },\n      responses: {\n        200: { description: \"Entry deleted\", content: { \"application/json\": { schema: z.object({ deleted: z.boolean(), namespace: z.string(), key: z.string() }) } } },\n        404: { description: \"Entry not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    handlers.handleDeleteEntry,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"delete\", path: \"/{id}\", tags: [\"Memory\"], summary: \"Clear all entries in a namespace\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"user-123\" }) }) },\n      responses: { 200: { description: \"Namespace cleared\", content: { \"application/json\": { schema: z.object({ cleared: z.boolean(), namespace: z.string() }) } } } },\n    }),\n    handlers.handleClearNamespace,\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/health/health.route.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext } from \"@kitnai/core\";\n\nexport function createHealthRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n\n  router.openapi(\n    createRoute({\n      method: \"get\",\n      path: \"/\",\n      tags: [\"Health\"],\n      summary: \"Health check\",\n      responses: {\n        200: {\n          description: \"Server is healthy\",\n          content: {\n            \"application/json\": {\n              schema: z.object({\n                status: z.string(),\n                timestamp: z.string(),\n                agents: z.number(),\n                tools: z.number(),\n              }),\n            },\n          },\n        },\n      },\n    }),\n    (c) => {\n      return c.json({\n        status: \"ok\",\n        timestamp: new Date().toISOString(),\n        agents: ctx.agents.list().length,\n        tools: ctx.tools.list().length,\n      });\n    },\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/agents/agents.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext, DelegationContext } from \"@kitnai/core\";\nimport { agentRequestSchema, agentPatchSchema, AgentEventBus, delegationStore, cancelRequest } from \"@kitnai/core\";\n\nexport function createAgentsRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n\n  const agentBody = {\n    content: { \"application/json\": { schema: agentRequestSchema } },\n  };\n\n  // GET / — List all registered agents\n  router.openapi(\n    createRoute({\n      method: \"get\",\n      path: \"/\",\n      tags: [\"Agents\"],\n      summary: \"List all registered agents\",\n      description: \"Returns metadata for all registered agents\",\n      responses: {\n        200: {\n          description: \"List of agents\",\n          content: {\n            \"application/json\": {\n              schema: z.object({\n                agents: z.array(\n                  z.object({\n                    name: z.string(),\n                    description: z.string(),\n                    defaultFormat: z.string(),\n                    formats: z.array(z.string()),\n                    toolNames: z.array(z.string()),\n                    hasPromptOverride: z.boolean(),\n                    actions: z.array(z.string()).optional(),\n                    isOrchestrator: z.boolean().optional(),\n                    agents: z.array(z.string()).optional(),\n                  }),\n                ),\n                count: z.number(),\n              }),\n            },\n          },\n        },\n      },\n    }),\n    (c) => {\n      const agents = ctx.agents.list().map((a) => {\n        const formats: string[] = [];\n        if (a.jsonHandler) formats.push(\"json\");\n        if (a.sseHandler) formats.push(\"sse\");\n        return {\n          name: a.name,\n          description: a.description,\n          defaultFormat: a.defaultFormat,\n          formats,\n          toolNames: a.toolNames,\n          hasPromptOverride: ctx.agents.hasPromptOverride(a.name),\n          actions: a.actions?.map((act) => `${act.method.toUpperCase()} /${a.name}/${act.name}`),\n          ...(a.isOrchestrator && { isOrchestrator: true }),\n          ...(a.agents && { agents: a.agents }),\n        };\n      });\n      return c.json({ agents, count: agents.length });\n    },\n  );\n\n  // GET /:agentName — Get agent details\n  router.openapi(\n    createRoute({\n      method: \"get\",\n      path: \"/{agentName}\",\n      tags: [\"Agents\"],\n      summary: \"Get agent details\",\n      description: \"Returns agent metadata and current system prompt\",\n      request: {\n        params: z.object({ agentName: z.string().openapi({ example: \"weather\" }) }),\n      },\n      responses: {\n        200: {\n          description: \"Agent details\",\n          content: {\n            \"application/json\": {\n              schema: z.object({\n                name: z.string(),\n                description: z.string(),\n                defaultFormat: z.string(),\n                formats: z.array(z.string()),\n                toolNames: z.array(z.string()),\n                systemPrompt: z.string(),\n                isDefault: z.boolean(),\n                actions: z.array(z.object({\n                  name: z.string(),\n                  method: z.string(),\n                  summary: z.string(),\n                  description: z.string(),\n                })).optional(),\n              }),\n            },\n          },\n        },\n        404: { description: \"Agent not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    ((c: any) => {\n      const name = c.req.param(\"agentName\");\n      const agent = ctx.agents.get(name);\n      if (!agent) return c.json({ error: `Agent not found: ${name}` }, 404);\n\n      const formats: string[] = [];\n      if (agent.jsonHandler) formats.push(\"json\");\n      if (agent.sseHandler) formats.push(\"sse\");\n\n      return c.json({\n        name: agent.name,\n        description: agent.description,\n        defaultFormat: agent.defaultFormat,\n        formats,\n        toolNames: agent.toolNames,\n        systemPrompt: ctx.agents.getResolvedPrompt(name) ?? \"\",\n        isDefault: !ctx.agents.hasPromptOverride(name),\n        actions: agent.actions?.map((act) => ({\n          name: act.name, method: act.method, summary: act.summary, description: act.description,\n        })),\n      });\n    }) as any,\n  );\n\n  // PATCH /:agentName — Update system prompt\n  router.openapi(\n    createRoute({\n      method: \"patch\",\n      path: \"/{agentName}\",\n      tags: [\"Agents\"],\n      summary: \"Update agent system prompt\",\n      description: \"Set a custom system prompt or reset to default\",\n      request: {\n        params: z.object({ agentName: z.string().openapi({ example: \"weather\" }) }),\n        body: { content: { \"application/json\": { schema: agentPatchSchema } } },\n      },\n      responses: {\n        200: {\n          description: \"Prompt updated\",\n          content: {\n            \"application/json\": {\n              schema: z.object({ name: z.string(), systemPrompt: z.string(), isDefault: z.boolean() }),\n            },\n          },\n        },\n        404: { description: \"Agent not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      const name = c.req.param(\"agentName\");\n      const agent = ctx.agents.get(name);\n      if (!agent) return c.json({ error: `Agent not found: ${name}` }, 404);\n\n      const body = await c.req.json();\n      if (body.reset) {\n        ctx.agents.resetPrompt(name);\n        await ctx.storage.prompts.deleteOverride(name);\n      } else if (body.system) {\n        ctx.agents.setPromptOverride(name, body.system);\n        await ctx.storage.prompts.saveOverride(name, body.system);\n      }\n\n      return c.json({\n        name,\n        systemPrompt: ctx.agents.getResolvedPrompt(name) ?? \"\",\n        isDefault: !ctx.agents.hasPromptOverride(name),\n      });\n    }) as any,\n  );\n\n  // POST /cancel\n  router.openapi(\n    createRoute({\n      method: \"post\",\n      path: \"/cancel\",\n      tags: [\"Agents\"],\n      summary: \"Cancel an active agent stream\",\n      description: \"Aborts a running agent request identified by conversationId\",\n      request: {\n        body: { content: { \"application/json\": { schema: z.object({ conversationId: z.string() }) } } },\n      },\n      responses: {\n        200: {\n          description: \"Cancellation result\",\n          content: {\n            \"application/json\": { schema: z.object({ cancelled: z.boolean(), conversationId: z.string() }) },\n          },\n        },\n      },\n    }),\n    async (c) => {\n      const { conversationId } = await c.req.json();\n      const cancelled = cancelRequest(conversationId);\n      return c.json({ cancelled, conversationId });\n    },\n  );\n\n  // POST /:agentName/:action — Agent actions\n  router.openapi(\n    createRoute({\n      method: \"post\",\n      path: \"/{agentName}/{action}\",\n      tags: [\"Agents\"],\n      summary: \"Execute an agent action\",\n      description: \"Dispatches to a named action on the agent\",\n      request: {\n        params: z.object({\n          agentName: z.string().openapi({ example: \"human-in-loop\" }),\n          action: z.string().openapi({ example: \"approve\" }),\n        }),\n        body: { content: { \"application/json\": { schema: z.any() } } },\n      },\n      responses: {\n        200: { description: \"Action result\", content: { \"application/json\": { schema: z.any() } } },\n        404: { description: \"Agent or action not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      const agentName = c.req.param(\"agentName\");\n      const actionName = c.req.param(\"action\");\n      const agent = ctx.agents.get(agentName);\n      if (!agent) return c.json({ error: `Agent not found: ${agentName}` }, 404);\n      const action = agent.actions?.find((a) => a.name === actionName);\n      if (!action) return c.json({ error: `Action not found: ${actionName} on agent ${agentName}` }, 404);\n      return action.handler(c);\n    }) as any,\n  );\n\n  // POST /:agentName — Dynamic dispatch\n  router.openapi(\n    createRoute({\n      method: \"post\",\n      path: \"/{agentName}\",\n      tags: [\"Agents\"],\n      summary: \"Execute an agent\",\n      description: \"Dispatches to the named agent. Use ?format=json or ?format=sse.\",\n      request: {\n        params: z.object({ agentName: z.string().openapi({ example: \"weather\" }) }),\n        body: agentBody,\n      },\n      responses: {\n        200: { description: \"Agent response\", content: { \"application/json\": { schema: z.any() } } },\n        400: { description: \"Unsupported format\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n        404: { description: \"Agent not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      const name = c.req.param(\"agentName\");\n      const agent = ctx.agents.get(name);\n      if (!agent) return c.json({ error: `Agent not found: ${name}` }, 404);\n\n      const format = (c.req.query(\"format\") ?? agent.defaultFormat) as \"json\" | \"sse\";\n      const handler = format === \"sse\" ? agent.sseHandler : agent.jsonHandler;\n\n      if (!handler) {\n        const supported = [agent.jsonHandler && \"json\", agent.sseHandler && \"sse\"].filter(Boolean);\n        return c.json({ error: `Agent \"${name}\" does not support format \"${format}\". Supported: ${supported.join(\", \")}` }, 400);\n      }\n\n      const systemPrompt = ctx.agents.getResolvedPrompt(name) ?? \"\";\n\n      let memoryContext: string | undefined;\n      try {\n        const body = await c.req.json();\n        if (body.memoryIds && Array.isArray(body.memoryIds) && body.memoryIds.length > 0) {\n          const memories = await ctx.storage.memory.loadMemoriesForIds(body.memoryIds);\n          if (memories.length > 0) {\n            memoryContext = memories.map((m) => `[${m.namespace}] ${m.key}: ${m.value}`).join(\"\\n\");\n          }\n        }\n      } catch { /* body parsing may fail on re-read */ }\n\n      if (format === \"sse\") {\n        const bus = new AgentEventBus();\n        const delegationCtx: DelegationContext = { chain: [], depth: 0, events: bus, orchestrator: name };\n        return delegationStore.run(delegationCtx, () => handler(c, { systemPrompt, memoryContext }));\n      }\n\n      return handler(c, { systemPrompt, memoryContext });\n    }) as any,\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/voice/voice.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext } from \"@kitnai/core\";\nimport { speakRequestSchema, transcribeResponseSchema, speakersResponseSchema, generateConversationId, runAgent } from \"@kitnai/core\";\nimport type { AIPluginConfig } from \"../../types.js\";\n\nconst AUDIO_MIME_TYPES: Record<string, string> = {\n  mp3: \"audio/mpeg\",\n  opus: \"audio/opus\",\n  wav: \"audio/wav\",\n  aac: \"audio/aac\",\n  flac: \"audio/flac\",\n};\n\nexport function createVoiceRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n\n  function requireVoice(name?: string) {\n    const provider = ctx.voice?.get(name);\n    if (!provider) throw new Error(\"VOICE_UNAVAILABLE\");\n    return provider;\n  }\n\n  // GET /speakers\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/speakers\", tags: [\"Voice\"], summary: \"List available voice speakers\",\n      responses: {\n        200: { description: \"List of speakers\", content: { \"application/json\": { schema: speakersResponseSchema } } },\n        503: { description: \"Voice provider not configured\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      let provider;\n      try { provider = requireVoice(); } catch { return c.json({ error: \"Voice provider not configured.\" }, 503); }\n      const speakers = await provider.getSpeakers();\n      return c.json({ speakers: speakers.map((s) => ({ voiceId: s.voiceId, name: s.name })), provider: provider.name });\n    }) as any,\n  );\n\n  // GET /providers\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/providers\", tags: [\"Voice\"], summary: \"List available transcription providers\",\n      responses: { 200: { description: \"List of providers\", content: { \"application/json\": { schema: z.object({ providers: z.array(z.object({ name: z.string(), label: z.string(), isDefault: z.boolean() })) }) } } } },\n    }),\n    async (c) => {\n      if (!ctx.voice) return c.json({ providers: [] });\n      const providers = ctx.voice.list();\n      const defaultName = ctx.voice.getDefault();\n      return c.json({ providers: providers.map((p) => ({ name: p.name, label: p.label, isDefault: p.name === defaultName })) });\n    },\n  );\n\n  // POST /transcribe\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/transcribe\", tags: [\"Voice\"], summary: \"Transcribe audio to text\",\n      request: {\n        query: z.object({ provider: z.string().optional() }),\n        body: { content: { \"multipart/form-data\": { schema: z.object({ audio: z.any().openapi({ type: \"string\", format: \"binary\" }), language: z.string().optional(), prompt: z.string().optional() }) } } },\n      },\n      responses: {\n        200: { description: \"Transcription result\", content: { \"application/json\": { schema: transcribeResponseSchema } } },\n        400: { description: \"No audio file\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n        503: { description: \"Voice provider not configured\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      const providerName = c.req.query(\"provider\") || undefined;\n      let provider;\n      try { provider = requireVoice(providerName); } catch {\n        return c.json({ error: providerName ? `Voice provider \"${providerName}\" not available.` : \"Voice provider not configured.\" }, 503);\n      }\n      const formData = await c.req.formData();\n      const audioFile = formData.get(\"audio\") as File | null;\n      if (!audioFile) return c.json({ error: \"No audio file provided.\" }, 400);\n\n      const language = formData.get(\"language\") as string | null;\n      const prompt = formData.get(\"prompt\") as string | null;\n      const retainAudio = formData.get(\"retainAudio\") === \"true\" || (ctx.config as AIPluginConfig).voice?.retainAudio;\n\n      let result;\n      try {\n        result = await provider.transcribe(audioFile, {\n          language: language ?? undefined,\n          prompt: prompt ?? undefined,\n        });\n      } catch (err: unknown) {\n        const message = err instanceof Error ? err.message : String(err);\n        console.error(\"[voice/transcribe] Transcription failed:\", message);\n        return c.json({ error: message || \"Transcription failed\" }, 502);\n      }\n\n      let audioId: string | undefined;\n      if (retainAudio) {\n        const buf = Buffer.from(await audioFile.arrayBuffer());\n        const entry = await ctx.storage.audio.saveAudio(buf, audioFile.type || \"audio/webm\", { transcription: result.text, source: \"transcribe\" });\n        audioId = entry.id;\n      }\n\n      return c.json({ ...result, provider: provider.name, ...(audioId && { audioId }) });\n    }) as any,\n  );\n\n  // POST /speak\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/speak\", tags: [\"Voice\"], summary: \"Convert text to speech\",\n      request: { body: { content: { \"application/json\": { schema: speakRequestSchema } } } },\n      responses: {\n        200: { description: \"Audio stream\" },\n        503: { description: \"Voice provider not configured\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      let provider;\n      try { provider = requireVoice(); } catch { return c.json({ error: \"Voice provider not configured.\" }, 503); }\n\n      const body = await c.req.json();\n      const { text, speaker, format, speed, model, save } = body;\n      const audioFormat = format ?? \"mp3\";\n      const audioStream = await provider.speak(text, { speaker, format: audioFormat, speed, model });\n\n      const mimeType = AUDIO_MIME_TYPES[audioFormat] ?? \"audio/mpeg\";\n\n      if (save) {\n        const chunks: Uint8Array[] = [];\n        const reader = audioStream instanceof ReadableStream ? audioStream.getReader() : null;\n        if (reader) {\n          while (true) { const { done, value } = await reader.read(); if (done) break; chunks.push(value); }\n        } else {\n          for await (const chunk of audioStream as AsyncIterable<Uint8Array>) { chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk)); }\n        }\n        const buffer = Buffer.concat(chunks);\n        const entry = await ctx.storage.audio.saveAudio(buffer, mimeType, { text, speaker, source: \"speak\" });\n        return new Response(new Uint8Array(buffer), { headers: { \"Content-Type\": mimeType, \"Content-Length\": String(buffer.length), \"X-Audio-Id\": entry.id } });\n      }\n\n      return new Response(audioStream, { headers: { \"Content-Type\": mimeType, \"Transfer-Encoding\": \"chunked\" } });\n    }) as any,\n  );\n\n  // POST /converse\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/converse\", tags: [\"Voice\"],\n      summary: \"Voice conversation (audio in, audio out)\",\n      description: \"Full cycle: transcribe audio -> run agent -> speak response.\",\n      request: {\n        query: z.object({ provider: z.string().optional() }),\n        body: { content: { \"multipart/form-data\": { schema: z.object({\n          audio: z.any().openapi({ type: \"string\", format: \"binary\" }),\n          speaker: z.string().optional(), format: z.string().optional(), speed: z.string().optional(),\n          model: z.string().optional(), conversationId: z.string().optional(), agent: z.string().optional(),\n        }) } } },\n      },\n      responses: {\n        200: { description: \"Audio response stream with metadata headers\" },\n        400: { description: \"No audio file\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n        503: { description: \"Voice provider not configured\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      const sttProviderName = c.req.query(\"provider\") || undefined;\n      let provider;\n      try { provider = requireVoice(sttProviderName); } catch { return c.json({ error: \"Voice provider not configured.\" }, 503); }\n      // Use default provider for TTS (speak) if STT provider differs\n      const ttsProvider = sttProviderName ? requireVoice() : provider;\n\n      const formData = await c.req.formData();\n      const audioFile = formData.get(\"audio\") as File | null;\n      if (!audioFile) return c.json({ error: \"No audio file provided.\" }, 400);\n\n      const speaker = (formData.get(\"speaker\") as string) ?? undefined;\n      const format = (formData.get(\"format\") as string) ?? \"mp3\";\n      const speed = formData.get(\"speed\") ? parseFloat(formData.get(\"speed\") as string) : undefined;\n      const model = (formData.get(\"model\") as string) ?? undefined;\n      const conversationId = (formData.get(\"conversationId\") as string) ?? undefined;\n\n      // Step 1: Transcribe\n      let transcription;\n      try {\n        transcription = await provider.transcribe(audioFile);\n      } catch (err: unknown) {\n        const message = err instanceof Error ? err.message : String(err);\n        console.error(\"[voice/converse] Transcription failed:\", message);\n        return c.json({ error: message || \"Transcription failed\" }, 502);\n      }\n      if (!transcription.text.trim()) return c.json({ error: \"Could not transcribe audio.\" }, 400);\n\n      // Step 2: Run agent — prefer a regular agent with tools (not the orchestrator)\n      const requestedAgent = formData.get(\"agent\") as string | null;\n      const orchestrators = ctx.agents.getOrchestratorNames();\n      const regularAgents = ctx.agents.list().filter((a) => !orchestrators.has(a.name) && a.tools && Object.keys(a.tools).length > 0);\n      const agentName = requestedAgent ?? regularAgents[0]?.name ?? ctx.agents.list()[0]?.name ?? \"assistant\";\n      const agent = ctx.agents.get(agentName);\n      const systemPrompt = agent ? ctx.agents.getResolvedPrompt(agentName) ?? \"\" : \"You are a helpful assistant.\";\n      const agentResult = await runAgent(ctx, { system: systemPrompt, tools: agent?.tools ?? {} }, transcription.text, model);\n      const responseText = agentResult.response;\n      const convId = generateConversationId(conversationId);\n\n      // Step 3: Speak response\n      const audioFormat = (format as \"mp3\" | \"opus\" | \"wav\" | \"aac\" | \"flac\") ?? \"mp3\";\n      const audioStream = await ttsProvider.speak(responseText, { speaker, format: audioFormat, speed });\n\n      return new Response(audioStream, {\n        headers: {\n          \"Content-Type\": AUDIO_MIME_TYPES[audioFormat] ?? \"audio/mpeg\",\n          \"Transfer-Encoding\": \"chunked\",\n          \"X-Transcription\": encodeURIComponent(transcription.text),\n          \"X-Response-Text\": encodeURIComponent(responseText),\n          \"X-Conversation-Id\": convId,\n        },\n      });\n    }) as any,\n  );\n\n  // GET /audio\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/audio\", tags: [\"Voice\"], summary: \"List stored audio entries\",\n      responses: { 200: { description: \"List of audio entries\", content: { \"application/json\": { schema: z.object({ entries: z.array(z.object({ id: z.string(), mimeType: z.string(), size: z.number(), createdAt: z.string() })), count: z.number() }) } } } },\n    }),\n    async (c) => {\n      const entries = await ctx.storage.audio.listAudio();\n      return c.json({ entries, count: entries.length });\n    },\n  );\n\n  // GET /audio/:id\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/audio/{id}\", tags: [\"Voice\"], summary: \"Get stored audio file\",\n      request: { params: z.object({ id: z.string() }) },\n      responses: { 200: { description: \"Audio file\" }, 404: { description: \"Audio not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } } },\n    }),\n    // hono/zod-openapi handler type mismatch\n    (async (c: any) => {\n      const id = c.req.param(\"id\");\n      const result = await ctx.storage.audio.getAudio(id);\n      if (!result) return c.json({ error: `Audio not found: ${id}` }, 404);\n      return new Response(new Uint8Array(result.data), { headers: { \"Content-Type\": result.entry.mimeType, \"Content-Length\": String(result.entry.size) } });\n    }) as any,\n  );\n\n  // DELETE /audio/:id\n  router.openapi(\n    createRoute({\n      method: \"delete\", path: \"/audio/{id}\", tags: [\"Voice\"], summary: \"Delete stored audio file\",\n      request: { params: z.object({ id: z.string() }) },\n      responses: { 200: { description: \"Deletion result\", content: { \"application/json\": { schema: z.object({ deleted: z.boolean() }) } } } },\n    }),\n    async (c) => {\n      const id = c.req.param(\"id\");\n      const deleted = await ctx.storage.audio.deleteAudio(id);\n      return c.json({ deleted });\n    },\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/conversations/conversations.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport { compactConversation } from \"@kitnai/core\";\nimport type { PluginContext } from \"@kitnai/core\";\n\nexport function createConversationsRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n  const store = ctx.storage.conversations;\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/\", tags: [\"Conversations\"], summary: \"List all conversations\",\n      responses: { 200: { description: \"All conversations\", content: { \"application/json\": { schema: z.object({ conversations: z.array(z.object({ id: z.string(), messageCount: z.number(), updatedAt: z.string() })), count: z.number() }) } } } },\n    }),\n    async (c) => {\n      const conversations = await store.list();\n      return c.json({ conversations, count: conversations.length }, 200);\n    },\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/{id}\", tags: [\"Conversations\"], summary: \"Get a conversation\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"conv_kanban_taskboard\" }) }) },\n      responses: {\n        200: { description: \"Full conversation\", content: { \"application/json\": { schema: z.object({ id: z.string(), messages: z.array(z.object({ role: z.enum([\"user\", \"assistant\"]), content: z.string(), timestamp: z.string() })), createdAt: z.string(), updatedAt: z.string() }) } } },\n        404: { description: \"Conversation not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    async (c) => {\n      const { id } = c.req.param();\n      const conv = await store.get(id);\n      if (!conv) return c.json({ error: \"Conversation not found\" }, 404);\n      return c.json(conv, 200);\n    },\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/\", tags: [\"Conversations\"], summary: \"Create a new conversation\",\n      request: { body: { content: { \"application/json\": { schema: z.object({ id: z.string().openapi({ example: \"conv_kanban_taskboard\" }) }) } } } },\n      responses: { 200: { description: \"Created conversation\", content: { \"application/json\": { schema: z.object({ id: z.string(), messages: z.array(z.any()), createdAt: z.string(), updatedAt: z.string() }) } } } },\n    }),\n    async (c) => {\n      const { id } = await c.req.json();\n      const conv = await store.create(id);\n      return c.json(conv, 200);\n    },\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"delete\", path: \"/{id}\", tags: [\"Conversations\"], summary: \"Delete a conversation\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"conv_kanban_taskboard\" }) }) },\n      responses: { 200: { description: \"Conversation deleted\", content: { \"application/json\": { schema: z.object({ deleted: z.boolean(), id: z.string() }) } } } },\n    }),\n    async (c) => {\n      const { id } = c.req.param();\n      const deleted = await store.delete(id);\n      return c.json({ deleted, id }, 200);\n    },\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"delete\", path: \"/{id}/messages\", tags: [\"Conversations\"], summary: \"Clear conversation messages\",\n      request: { params: z.object({ id: z.string().openapi({ example: \"conv_kanban_taskboard\" }) }) },\n      responses: {\n        200: { description: \"Messages cleared\", content: { \"application/json\": { schema: z.object({ id: z.string(), messages: z.array(z.any()), createdAt: z.string(), updatedAt: z.string() }) } } },\n        404: { description: \"Conversation not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    async (c) => {\n      const { id } = c.req.param();\n      try {\n        const conv = await store.clear(id);\n        return c.json(conv, 200);\n      } catch {\n        return c.json({ error: \"Conversation not found\" }, 404);\n      }\n    },\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/{id}/compact\", tags: [\"Conversations\"], summary: \"Compact conversation by summarizing older messages\",\n      request: {\n        params: z.object({ id: z.string().openapi({ example: \"conv_kanban_taskboard\" }) }),\n        body: { content: { \"application/json\": { schema: z.object({ preserveRecent: z.number().optional(), prompt: z.string().optional(), model: z.string().optional() }) } }, required: false },\n      },\n      responses: {\n        200: { description: \"Compaction result\", content: { \"application/json\": { schema: z.object({ conversationId: z.string(), summary: z.string(), summarizedCount: z.number(), preservedCount: z.number(), newMessageCount: z.number() }) } } },\n        404: { description: \"Conversation not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    async (c) => {\n      const { id } = c.req.param();\n      const body = await c.req.json().catch(() => ({}));\n      const result = await compactConversation(ctx, id, body);\n      if (!result) return c.json({ error: \"Conversation not found\" }, 404);\n      return c.json({ conversationId: id, ...result }, 200);\n    },\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/generate/generate.handlers.ts",
      "content": "import type { Context } from \"hono\";\nimport { streamSSE } from \"hono/streaming\";\nimport { generateText, streamText, stepCountIs } from \"ai\";\nimport { extractUsage, extractStreamUsage, SSE_EVENTS, withResilience } from \"@kitnai/core\";\nimport type { PluginContext } from \"@kitnai/core\";\n\nexport function createGenerateHandlers(ctx: PluginContext) {\n  /** Resolve tools from the tool registry by name */\n  function resolveTools(names: string[]): { tools: Record<string, any>; unknown: string[] } {\n    const unknown: string[] = [];\n    const tools: Record<string, any> = {};\n    for (const name of names) {\n      const reg = ctx.tools.get(name);\n      if (!reg) {\n        unknown.push(name);\n      } else {\n        tools[name] = reg.tool;\n      }\n    }\n    return { tools, unknown };\n  }\n\n  async function handleGenerate(c: Context) {\n    const body = await c.req.json();\n    const { prompt, systemPrompt, model, tools: toolNames, maxSteps } = body;\n\n    let tools: Record<string, any> | undefined;\n    if (toolNames?.length) {\n      const resolved = resolveTools(toolNames);\n      if (resolved.unknown.length > 0) {\n        return c.json({ error: `Unknown tool(s): ${resolved.unknown.join(\", \")}` }, 400);\n      }\n      tools = resolved.tools;\n    }\n\n    const startTime = performance.now();\n    const result = await withResilience({\n      fn: (overrideModel) => generateText({\n        model: ctx.getModel(overrideModel ?? model),\n        system: systemPrompt,\n        prompt,\n        tools,\n        stopWhen: tools ? stepCountIs(maxSteps ?? 5) : undefined,\n      }),\n      ctx, modelId: model,\n    });\n\n    const toolResults = result.steps\n      .flatMap((step) => step.toolResults)\n      .filter(Boolean);\n\n    return c.json({\n      text: result.text,\n      model: model ?? \"default\",\n      usage: extractUsage(result, startTime),\n      toolResults: toolResults.length > 0 ? toolResults : undefined,\n      finishReason: result.finishReason,\n    }, 200);\n  }\n\n  async function handleGenerateStream(c: Context) {\n    const body = await c.req.json();\n    const { prompt, systemPrompt, model, tools: toolNames, maxSteps } = body;\n\n    let tools: Record<string, any> | undefined;\n    if (toolNames?.length) {\n      const resolved = resolveTools(toolNames);\n      if (resolved.unknown.length > 0) {\n        return c.json({ error: `Unknown tool(s): ${resolved.unknown.join(\", \")}` }, 400);\n      }\n      tools = resolved.tools;\n    }\n\n    const startTime = performance.now();\n    const result = streamText({\n      model: ctx.getModel(model),\n      system: systemPrompt,\n      prompt,\n      tools,\n      stopWhen: tools ? stepCountIs(maxSteps ?? 5) : undefined,\n    });\n\n    return streamSSE(c, async (stream) => {\n      let id = 0;\n      for await (const text of result.textStream) {\n        await stream.writeSSE({\n          id: String(id++),\n          event: SSE_EVENTS.TEXT_DELTA,\n          data: JSON.stringify({ text }),\n        });\n      }\n\n      const usage = await result.usage;\n      const usageInfo = extractStreamUsage(usage, startTime);\n\n      await stream.writeSSE({\n        id: String(id++),\n        event: SSE_EVENTS.DONE,\n        data: JSON.stringify({\n          finishReason: await result.finishReason,\n          usage: usageInfo,\n        }),\n      });\n    });\n  }\n\n  return { handleGenerate, handleGenerateStream };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/generate/generate.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext } from \"@kitnai/core\";\nimport { generateRequestSchema, generateResponseSchema } from \"@kitnai/core\";\nimport { createGenerateHandlers } from \"./generate.handlers.js\";\n\nexport function createGenerateRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n  const handlers = createGenerateHandlers(ctx);\n\n  router.openapi(\n    createRoute({\n      method: \"post\",\n      path: \"/\",\n      tags: [\"RAG\"],\n      summary: \"Generate text\",\n      description: \"Generate a response from the AI model. Optionally provide tools. Use ?format=sse for streaming.\",\n      request: {\n        body: { content: { \"application/json\": { schema: generateRequestSchema } } },\n      },\n      responses: {\n        200: {\n          description: \"Generated response\",\n          content: { \"application/json\": { schema: generateResponseSchema } },\n        },\n      },\n    }),\n    // hono/zod-openapi handler type mismatch\n    ((c: any) => {\n      const format = (c.req.query(\"format\") ?? \"json\") as \"json\" | \"sse\";\n      if (format === \"sse\") return handlers.handleGenerateStream(c);\n      return handlers.handleGenerate(c);\n    }) as any,\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/skills/skills.handlers.ts",
      "content": "import type { Context } from \"hono\";\nimport type { PluginContext } from \"@kitnai/core\";\n\nexport function createSkillsHandlers(ctx: PluginContext) {\n  const store = ctx.storage.skills;\n\n  return {\n    async handleListSkills(c: Context) {\n      const skills = await store.listSkills();\n      return c.json({ skills, count: skills.length }, 200);\n    },\n\n    async handleGetSkill(c: Context) {\n      const name = c.req.param(\"name\");\n      const skill = await store.getSkill(name);\n      if (!skill) return c.json({ error: \"Skill not found\" }, 404);\n      return c.json(skill, 200);\n    },\n\n    async handleCreateSkill(c: Context) {\n      const { name, content } = await c.req.json();\n      try {\n        const skill = await store.createSkill(name, content);\n        return c.json(skill, 201);\n      } catch (err: unknown) {\n        const message = err instanceof Error ? err.message : String(err);\n        return c.json({ error: message }, 400);\n      }\n    },\n\n    async handleUpdateSkill(c: Context) {\n      const name = c.req.param(\"name\");\n      const { content } = await c.req.json();\n      try {\n        const skill = await store.updateSkill(name, content);\n        return c.json(skill, 200);\n      } catch (err: unknown) {\n        const message = err instanceof Error ? err.message : String(err);\n        return c.json({ error: message }, 404);\n      }\n    },\n\n    async handleDeleteSkill(c: Context) {\n      const name = c.req.param(\"name\");\n      const deleted = await store.deleteSkill(name);\n      if (!deleted) return c.json({ error: \"Skill not found\" }, 404);\n      return c.json({ deleted: true, name }, 200);\n    },\n  };\n}\n",
      "type": "kitn:package"
    },
    {
      "path": "routes/routes/skills/skills.routes.ts",
      "content": "import { createRoute, z } from \"@hono/zod-openapi\";\nimport { OpenAPIHono } from \"@hono/zod-openapi\";\nimport type { PluginContext } from \"@kitnai/core\";\nimport { skillMetaSchema, skillSchema, skillCreateSchema, skillUpdateSchema } from \"@kitnai/core\";\nimport { createSkillsHandlers } from \"./skills.handlers.js\";\n\nexport function createSkillsRoutes(ctx: PluginContext) {\n  const router = new OpenAPIHono();\n  const handlers = createSkillsHandlers(ctx);\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/\", tags: [\"Skills\"], summary: \"List all skills\",\n      responses: { 200: { description: \"All skills\", content: { \"application/json\": { schema: z.object({ skills: z.array(skillMetaSchema), count: z.number() }) } } } },\n    }),\n    handlers.handleListSkills,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"get\", path: \"/{name}\", tags: [\"Skills\"], summary: \"Get a specific skill by name\",\n      request: { params: z.object({ name: z.string().openapi({ example: \"eli5\" }) }) },\n      responses: {\n        200: { description: \"Skill details\", content: { \"application/json\": { schema: skillSchema } } },\n        404: { description: \"Skill not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    handlers.handleGetSkill,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"post\", path: \"/\", tags: [\"Skills\"], summary: \"Create a new skill\",\n      request: { body: { content: { \"application/json\": { schema: skillCreateSchema } } } },\n      responses: {\n        201: { description: \"Skill created\", content: { \"application/json\": { schema: skillSchema } } },\n        400: { description: \"Invalid input\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    handlers.handleCreateSkill,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"put\", path: \"/{name}\", tags: [\"Skills\"], summary: \"Update an existing skill\",\n      request: { params: z.object({ name: z.string().openapi({ example: \"eli5\" }) }), body: { content: { \"application/json\": { schema: skillUpdateSchema } } } },\n      responses: {\n        200: { description: \"Skill updated\", content: { \"application/json\": { schema: skillSchema } } },\n        404: { description: \"Skill not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    handlers.handleUpdateSkill,\n  );\n\n  router.openapi(\n    createRoute({\n      method: \"delete\", path: \"/{name}\", tags: [\"Skills\"], summary: \"Delete a skill\",\n      request: { params: z.object({ name: z.string().openapi({ example: \"eli5\" }) }) },\n      responses: {\n        200: { description: \"Skill deleted\", content: { \"application/json\": { schema: z.object({ deleted: z.boolean(), name: z.string() }) } } },\n        404: { description: \"Skill not found\", content: { \"application/json\": { schema: z.object({ error: z.string() }) } } },\n      },\n    }),\n    handlers.handleDeleteSkill,\n  );\n\n  return router;\n}\n",
      "type": "kitn:package"
    }
  ],
  "installDir": "routes",
  "tsconfig": {
    "@kitnai/hono": [
      "./index.ts"
    ]
  },
  "docs": "Routes installed to your project. Import with: import { ... } from '@kitnai/hono'",
  "version": "1.0.0",
  "updatedAt": "2026-02-25T18:59:36.520Z"
}
