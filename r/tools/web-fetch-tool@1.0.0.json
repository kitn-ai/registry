{
  "$schema": "https://kitn.dev/schema/registry-item.json",
  "name": "web-fetch-tool",
  "type": "kitn:tool",
  "description": "Fetch web pages and extract readable text content or OpenGraph metadata",
  "dependencies": [
    "ai",
    "zod"
  ],
  "registryDependencies": [],
  "envVars": {},
  "files": [
    {
      "path": "tools/web-fetch.ts",
      "content": "import { tool } from \"ai\";\nimport { z } from \"zod\";\n\nconst MAX_CONTENT_LENGTH = 4000;\nconst FETCH_TIMEOUT_MS = 10000;\n\n/**\n * Strip HTML tags and extract readable text.\n * Lightweight regex-based approach -- no external deps.\n */\nfunction htmlToText(html: string): string {\n  return html\n    // Remove script and style blocks entirely\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, \"\")\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, \"\")\n    // Remove HTML comments\n    .replace(/<!--[\\s\\S]*?-->/g, \"\")\n    // Convert common block elements to newlines\n    .replace(/<\\/(p|div|h[1-6]|li|tr|br\\s*\\/?)>/gi, \"\\n\")\n    .replace(/<br\\s*\\/?>/gi, \"\\n\")\n    // Strip remaining tags\n    .replace(/<[^>]+>/g, \"\")\n    // Decode common HTML entities\n    .replace(/&amp;/g, \"&\")\n    .replace(/&lt;/g, \"<\")\n    .replace(/&gt;/g, \">\")\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&nbsp;/g, \" \")\n    // Collapse whitespace\n    .replace(/[ \\t]+/g, \" \")\n    // Trim each line so whitespace-only lines become truly empty\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .join(\"\\n\")\n    // Collapse multiple blank lines into one\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}\n\n/**\n * Extract <title> from HTML.\n */\nfunction extractTitle(html: string): string | null {\n  const match = html.match(/<title[^>]*>([\\s\\S]*?)<\\/title>/i);\n  return match ? match[1].trim() : null;\n}\n\n/**\n * Extract OpenGraph meta tags from the <head> section.\n * Handles both property= and name= attributes (some sites use name=\"og:...\"),\n * and any attribute ordering.\n */\nfunction extractOpenGraph(html: string): Record<string, string> {\n  const og: Record<string, string> = {};\n  // Only look in <head> to avoid false matches in body\n  const headMatch = html.match(/<head[\\s\\S]*?<\\/head>/i);\n  const head = headMatch ? headMatch[0] : html.slice(0, 5000);\n\n  // Match all <meta> tags, then inspect attributes individually\n  const metaTagRegex = /<meta\\s[^>]*>/gi;\n  let tagMatch: RegExpExecArray | null;\n\n  while ((tagMatch = metaTagRegex.exec(head)) !== null) {\n    const tag = tagMatch[0];\n\n    // Look for og: in either property= or name= attribute\n    const ogKeyMatch =\n      tag.match(/(?:property|name)=[\"']og:([^\"']+)[\"']/i);\n    const contentMatch = tag.match(/content=[\"']([^\"']*)[\"']/i);\n\n    if (ogKeyMatch && contentMatch) {\n      const key = ogKeyMatch[1];\n      if (!og[key]) {\n        og[key] = contentMatch[1];\n      }\n    }\n  }\n\n  return og;\n}\n\nexport const fetchPageTool = tool({\n  description:\n    \"Fetch a web page and extract its readable text content. Use this to get detailed information from a specific URL found via search.\",\n  inputSchema: z.object({\n    url: z.string().url().describe(\"The URL of the page to fetch\"),\n  }),\n  execute: async ({ url }) => {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);\n\n    try {\n      const res = await fetch(url, {\n        headers: {\n          \"User-Agent\":\n            \"Mozilla/5.0 (compatible; AIAgentBot/1.0)\",\n          Accept: \"text/html,application/xhtml+xml,*/*\",\n        },\n        signal: controller.signal,\n        redirect: \"follow\",\n      });\n\n      if (!res.ok) {\n        throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);\n      }\n\n      const html = await res.text();\n      const title = extractTitle(html);\n      let content = htmlToText(html);\n      const fullLength = content.length;\n\n      if (content.length > MAX_CONTENT_LENGTH) {\n        content = content.slice(0, MAX_CONTENT_LENGTH) + \"\\n\\n[Content truncated]\";\n      }\n\n      return {\n        url,\n        title: title ?? \"Untitled\",\n        content,\n        contentLength: fullLength,\n      };\n    } finally {\n      clearTimeout(timeout);\n    }\n  },\n});\n\nexport const getPageMetaTool = tool({\n  description:\n    \"Extract OpenGraph metadata from a web page for rich card display. Returns structured data including title, description, image URL, and site name.\",\n  inputSchema: z.object({\n    url: z.string().url().describe(\"The URL to extract OpenGraph metadata from\"),\n  }),\n  execute: async ({ url }) => {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);\n\n    try {\n      const res = await fetch(url, {\n        headers: {\n          \"User-Agent\":\n            \"Mozilla/5.0 (compatible; AIAgentBot/1.0)\",\n          Accept: \"text/html,application/xhtml+xml,*/*\",\n        },\n        signal: controller.signal,\n        redirect: \"follow\",\n      });\n\n      if (!res.ok) {\n        throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);\n      }\n\n      const html = await res.text();\n      const og = extractOpenGraph(html);\n      const title = extractTitle(html);\n\n      return {\n        url,\n        openGraph: {\n          title: og.title ?? title ?? null,\n          description: og.description ?? null,\n          image: og.image ?? null,\n          url: og.url ?? url,\n          siteName: og.site_name ?? null,\n          type: og.type ?? null,\n        },\n      };\n    } finally {\n      clearTimeout(timeout);\n    }\n  },\n});\n",
      "type": "kitn:tool"
    }
  ],
  "docs": "Provides two tools: fetchPageTool (extract readable text from URLs) and getPageMetaTool (extract OpenGraph metadata for rich cards).",
  "categories": [
    "web",
    "fetch",
    "scraping"
  ],
  "version": "1.0.0",
  "updatedAt": "2026-02-25T18:59:36.494Z"
}
