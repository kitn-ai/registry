{
  "$schema": "https://kitn.dev/schema/registry-item.json",
  "name": "memory-store",
  "type": "kitn:storage",
  "description": "File-based namespaced key-value memory store for agent memory persistence",
  "dependencies": [],
  "registryDependencies": [],
  "envVars": {},
  "files": [
    {
      "path": "storage/memory-store.ts",
      "content": "import { readFile, writeFile, mkdir, readdir, unlink } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\n\n/** A single key-value memory entry within a namespace */\nexport interface MemoryEntry {\n  key: string;\n  value: string;\n  context: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface MemoryStore {\n  listNamespaces(): Promise<string[]>;\n  listEntries(namespaceId: string): Promise<MemoryEntry[]>;\n  saveEntry(namespaceId: string, key: string, value: string, context?: string): Promise<MemoryEntry>;\n  getEntry(namespaceId: string, key: string): Promise<MemoryEntry | null>;\n  deleteEntry(namespaceId: string, key: string): Promise<boolean>;\n  clearNamespace(namespaceId: string): Promise<void>;\n  loadMemoriesForIds(ids: string[]): Promise<Array<MemoryEntry & { namespace: string }>>;\n}\n\ntype NamespaceData = Record<string, MemoryEntry>;\n\nexport function createMemoryStore(dataDir: string): MemoryStore {\n  const dir = join(dataDir, \"memory\");\n\n  const locks = new Map<string, Promise<void>>();\n  function withLock<T>(namespace: string, fn: () => Promise<T>): Promise<T> {\n    const prev = locks.get(namespace) ?? Promise.resolve();\n    let result: Promise<T>;\n    const next = prev\n      .then(async () => { result = fn(); await result; })\n      .catch(() => {});\n    locks.set(namespace, next);\n    return next.then(() => result!);\n  }\n\n  function namespacePath(namespaceId: string): string { return join(dir, `${namespaceId}.json`); }\n\n  async function ensureDir() {\n    if (!existsSync(dir)) await mkdir(dir, { recursive: true });\n  }\n\n  async function readNamespace(namespaceId: string): Promise<NamespaceData> {\n    await ensureDir();\n    const path = namespacePath(namespaceId);\n    if (!existsSync(path)) return {};\n    const raw = await readFile(path, \"utf-8\");\n    try { return JSON.parse(raw); } catch { return {}; }\n  }\n\n  async function writeNamespace(namespaceId: string, data: NamespaceData): Promise<void> {\n    await ensureDir();\n    await writeFile(namespacePath(namespaceId), JSON.stringify(data, null, 2));\n  }\n\n  return {\n    async listNamespaces() {\n      await ensureDir();\n      const files = await readdir(dir);\n      return files.filter((f) => f.endsWith(\".json\")).map((f) => f.replace(\".json\", \"\"));\n    },\n\n    async listEntries(namespaceId) {\n      const data = await readNamespace(namespaceId);\n      return Object.values(data);\n    },\n\n    saveEntry(namespaceId, key, value, context = \"\") {\n      return withLock(namespaceId, async () => {\n        const data = await readNamespace(namespaceId);\n        const now = new Date().toISOString();\n        const entry: MemoryEntry = {\n          key, value, context,\n          createdAt: data[key]?.createdAt ?? now,\n          updatedAt: now,\n        };\n        data[key] = entry;\n        await writeNamespace(namespaceId, data);\n        return entry;\n      });\n    },\n\n    async getEntry(namespaceId, key) {\n      const data = await readNamespace(namespaceId);\n      return data[key] ?? null;\n    },\n\n    deleteEntry(namespaceId, key) {\n      return withLock(namespaceId, async () => {\n        const data = await readNamespace(namespaceId);\n        if (!data[key]) return false;\n        delete data[key];\n        await writeNamespace(namespaceId, data);\n        return true;\n      });\n    },\n\n    clearNamespace(namespaceId) {\n      return withLock(namespaceId, async () => {\n        const path = namespacePath(namespaceId);\n        if (existsSync(path)) await unlink(path);\n      });\n    },\n\n    async loadMemoriesForIds(ids) {\n      const results: Array<MemoryEntry & { namespace: string }> = [];\n      await Promise.all(\n        ids.map(async (id) => {\n          const data = await readNamespace(id);\n          for (const entry of Object.values(data)) {\n            results.push({ ...entry, namespace: id });\n          }\n        }),\n      );\n      return results;\n    },\n  };\n}\n",
      "type": "kitn:storage"
    }
  ],
  "docs": "Call createMemoryStore(dataDir) with a path to your data directory. Memories are organized by namespace, each stored as a JSON file. Includes write locking per namespace.",
  "categories": [
    "storage",
    "memory",
    "persistence"
  ],
  "version": "1.0.0",
  "updatedAt": "2026-02-25T18:59:36.500Z"
}
